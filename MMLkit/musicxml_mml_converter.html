<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MusicXML to MML Converter</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" crossorigin="anonymous" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Flex:wght@600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: "Pretendard", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #fcfcfc;
      padding: 20px;
    }
    
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: #fcfcfc;
      padding: 30px;
    }
    
    h1 {
      margin-bottom: 24px;
      padding-bottom: 24px;
      border-bottom: 1px solid #e6e6e6;
      color: #0d0d0d;
      font-family: "Roboto Flex", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-weight: 600;
      font-stretch: 110%;
      letter-spacing: -0.2px;
    }
    
    .upload-section {
      margin-bottom: 12px;
      padding: 40px;
      background: #F0F2F5;
      border-radius: 8px;
      text-align: center;
    }
    
    .file-input-wrapper {
      position: relative;
      display: inline-block;
    }
    
    .file-input {
      display: none;
    }
    
    .upload-btn {
      padding: 12px 32px;
      background: #1741EA;
      color: #fcfcfc;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: background 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-family: "Pretendard", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    
    .upload-btn:hover {
      background: #0d2db8;
    }
    
    .file-info {
      margin-top: 16px;
      font-size: 14px;
      color: #666;
    }
    
    .progress-section {
  margin-bottom: 12px;
  padding: 16px 24px;
  background: #F0F2F5;
  border-radius: 8px;
  display: none;
  flex-direction: row;
  align-items: center;
  gap: 8px;
}

.progress-section.active {
  display: flex;
}

.progress-step {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 0;
  border-bottom: none;
  flex: 1;
}

.progress-step:last-child {
  border-bottom: none;
}
    
    .progress-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      flex-shrink: 0;
    }
    
    .progress-icon.pending {
      background: #e0e0e0;
      color: #999;
    }
    
    .progress-icon.active {
      background: #1741EA;
      color: white;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .progress-icon.complete {
      background: #10b981;
      color: white;
    }
    
    .progress-icon.error {
      background: #ef4444;
      color: white;
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.6;
      }
    }
    
    .progress-label {
      flex: 1;
      font-size: 14px;
      color: #333;
    }
    
    .progress-label.pending {
      color: #999;
    }
    
    .progress-label.active {
      color: #1741EA;
      font-weight: 500;
    }
    
    .progress-label.complete {
      color: #10b981;
    }
    
    .progress-label.error {
      color: #ef4444;
    }
    
    .options-section {
      margin-bottom: 12px;
      padding: 24px;
      background: #F0F2F5;
      border-radius: 8px;
    }
    
    .option-group {
      margin-bottom: 28px;
    }
    
    .option-group:last-child {
      margin-bottom: 0;
    }
    
    .option-group > label {
      display: block;
      font-weight: 600;
      margin-bottom: 16px;
      color: #0d0d0d;
      font-size: 16px;
    }
    
    .radio-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .radio-option {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .radio-option input[type="radio"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .radio-option label {
      margin: 0;
      font-weight: 400;
      cursor: pointer;
      font-size: 16px;
    }
    
    .sub-option {
      margin-left: 26px;
      margin-top: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .sub-option label {
      margin: 0;
      font-weight: 400;
      font-size: 14px;
      color: #666;
    }
    
    .sub-option select {
      padding: 6px 12px;
      border: 2px solid #e8e8e8;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      background: #fcfcfc;
    }
    
    .preview-section {
      margin-bottom: 30px;
    }
    
    .preview-section h2 {
      font-size: 18px;
      margin-bottom: 16px;
      color: #1a1a1a;
    }
    
    .preview-channels {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .preview-channel {
      padding: 15px;
      background: #F0F2F5;
      border-radius: 8px;
    }
    
    .preview-channel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .preview-channel-title {
      font-size: 14px;
      font-weight: 500;
      color: #1a1a1a;
      flex: 1;
    }
    
.copy-btn {
  padding: 4px 6px;
  background: #fcfcfc;
  border: 0.8px solid #8099FF;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #1741EA;
  transition: all 0.2s;
}
    
    .copy-btn svg {
      width: 14px;
      height: 14px;
    }
    
.copy-btn:hover {
  background: #f0f4ff;
  border-color: #1741EA;
  color: #1741EA;
}
    
    .copy-btn:active {
      transform: scale(0.95);
    }
    
    .preview-channel-content {
      padding: 12px;
      background: #fcfcfc;
      border-radius: 6px;
      font-family: "Pretendard", 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-wrap;
      max-height: 240px;
      overflow-y: auto;
      color: #333;
    }
    
    .preview-channel-content .error-line {
      background: #fee;
      color: #c00;
      padding: 2px 4px;
      border-radius: 3px;
      display: inline-block;
      margin: 2px 0;
    }
    
    .preview-channel-footer {
      margin-top: 4px;
      text-align: right;
      font-size: 12px;
      color: #999;
    }
    
    .preview-empty {
      padding: 40px;
      text-align: center;
      color: #999;
      font-style: italic;
      background: #F0F2F5;
      border-radius: 8px;
    }
    
    .actions {
      display: flex;
      gap: 12px;
    }
    
    .convert-btn, .download-btn {
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-family: "Pretendard", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    
    .convert-btn {
      background: #1741EA;
      color: #fcfcfc;
      border: none;
    }
    
    .convert-btn:hover:not(:disabled) {
      background: #0d2db8;
    }
    
    .convert-btn:disabled {
      background: #e6e6e6;
      color: #999;
      cursor: not-allowed;
    }
    
    .convert-btn.loading {
      background: #1741EA;
      cursor: wait;
    }
    
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .download-btn {
      background: #fcfcfc;
      color: #1741EA;
      border: 0.8px solid #8099FF;
    }
    
    .download-btn:hover:not(:disabled) {
      background: #f0f4ff;
    }
    
    .download-btn:disabled {
      background: #f5f5f5;
      color: #ccc;
      border-color: #e6e6e6;
      cursor: not-allowed;
    }
    
    .warning {
      margin-top: 20px;
      padding: 16px;
      background: #fff8e0;
      border-left: 3px solid #ffc107;
      border-radius: 6px;
      font-size: 14px;
      color: #856404;
    }
    
    .validation-warning {
      margin-top: 12px;
      margin-bottom: 12px;
      padding: 16px;
      background: #fff8e0;
      border-left: 3px solid #ffc107;
      border-radius: 6px;
      font-size: 14px;
      color: #856404;
    }
    
    .validation-warning strong {
      font-weight: 600;
    }
    
    .error-detail {
      margin-top: 8px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 4px;
      font-size: 12px;
      font-family: 'Courier New', monospace;
    }

    .rest-optimize-cb {
  accent-color: #1741EA;
}

.radio-option input[type="radio"] {
  accent-color: #1741EA;
}
  </style>
</head>
<body>
  <div class="container">
    <h1>  <div style="display: flex; align-items: center; gap: 16px;">
    <span>MusicXML to MML Converter</span>
    <a href="mml_player.html" style="font-size: 14px; color: #1741EA; text-decoration: none; font-weight: 400;">MML Player →</a>
  </div></h1>
    
    <div class="upload-section">
      <div class="file-input-wrapper">
        <input type="file" id="fileInput" class="file-input" accept=".xml,.musicxml,.mxl,application/xml,text/xml">
        <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
          MusicXML 파일 선택
        </button>
      </div>
      <div class="file-info" id="fileInfo">파일을 선택하지 않았습니다</div>
    </div>
    
    <div class="progress-section" id="progressSection">
      <div class="progress-step" id="step1">
        <div class="progress-icon pending">1</div>
        <div class="progress-label pending">파일 읽기</div>
      </div>
      <div class="progress-step" id="step2">
        <div class="progress-icon pending">2</div>
        <div class="progress-label pending">XML 파싱</div>
      </div>
      <div class="progress-step" id="step3">
        <div class="progress-icon pending">3</div>
        <div class="progress-label pending">MML 변환</div>
      </div>
      <div class="progress-step" id="step4">
        <div class="progress-icon pending">4</div>
        <div class="progress-label pending">최적화</div>
      </div>
    </div>

    <div class="validation-warning" id="validationWarningBox" style="display: none;"></div>
    <div class="warning" id="warningBox" style="display: none;"></div>
    
    <div class="options-section">
      <div class="option-group">
        <label>변환 모드</label>
        <div class="radio-group">
          <div class="radio-option">
            <input type="radio" id="melodyMode" name="mode" value="melody" checked>
            <label for="melodyMode">각 스태프의 최고음만 추출</label>
          </div>
          <div class="radio-option">
            <input type="radio" id="harmonyMode" name="mode" value="harmony">
            <label for="harmonyMode">화음 분리 (최고음 + 최저음)</label>
          </div>
        </div>
      </div>
      
    </div>
    
    <div class="actions">
      <button class="convert-btn" id="convertBtn" disabled>
        <span id="convertBtnText">변환하기</span>
      </button>
      <button class="download-btn" id="downloadBtn" disabled>TXT 다운로드</button>
    </div>
    
    <div class="preview-section" style="margin-top: 40px;">
      <h2>미리보기</h2>
      <div id="previewContainer">
        <div class="preview-empty">변환 결과가 여기에 표시됩니다</div>
      </div>
    </div>
  </div>

  <script>
    // 전역 변수
    let uploadedFile = null;
    let convertedMML = '';
    let isConverting = false;
    let validationErrors = [];
    let channelOriginalContents = {};
    
    // UI 관련 함수들
    
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (file) {
        uploadedFile = file;
        document.getElementById('fileInfo').textContent = `선택된 파일: ${file.name}`;
        document.getElementById('convertBtn').disabled = false;
        
        const previewContainer = document.getElementById('previewContainer');
        previewContainer.innerHTML = '<div class="preview-empty">변환 결과가 여기에 표시됩니다</div>';
        document.getElementById('downloadBtn').disabled = true;
        convertedMML = '';
        validationErrors = [];
        
        resetProgress();
        hideWarning();
        hideValidationWarning();
      }
    }
    
    function showWarning(message, errorDetail = null) {
      const warningBox = document.getElementById('warningBox');
      warningBox.innerHTML = message;
      
      if (errorDetail) {
        const detailDiv = document.createElement('div');
        detailDiv.className = 'error-detail';
        detailDiv.textContent = errorDetail;
        warningBox.appendChild(detailDiv);
      }
      
      warningBox.style.display = 'block';
    }
    
    function hideWarning() {
      document.getElementById('warningBox').style.display = 'none';
    }
    
    function showValidationWarning(errors) {
  const warningBox = document.getElementById('validationWarningBox');
  const errorCount = errors.length;

  let message = `<strong>⚠️ 수동 변환 필요: ${errorCount}건</strong><br><br>`;
  message += '<ul style="margin: 8px 0; padding-left: 20px;">';

  errors.forEach(err => {
    message += `<li>${err}</li>`;
  });

  message += '</ul>';

  warningBox.innerHTML = message;
  warningBox.style.display = 'block';
}
    
    function hideValidationWarning() {
      document.getElementById('validationWarningBox').style.display = 'none';
    }
    
    function getProgressStepLabel(stepNum) {
      const labels = {
        1: '파일 읽기',
        2: 'XML 파싱',
        3: 'MML 변환',
        4: '미리보기 출력'
      };
      return labels[stepNum] || '';
    }
    
    function resetProgress() {
      document.getElementById('progressSection').classList.remove('active');
      
      for (let i = 1; i <= 4; i++) {
        const step = document.getElementById(`step${i}`);
        const icon = step.querySelector('.progress-icon');
        const label = step.querySelector('.progress-label');
        
        icon.className = 'progress-icon pending';
        icon.textContent = i;
        label.className = 'progress-label pending';
        label.textContent = getProgressStepLabel(i);
      }
    }
    
    function updateProgress(stepNum, status, message = null) {
      const step = document.getElementById(`step${stepNum}`);
      const icon = step.querySelector('.progress-icon');
      const label = step.querySelector('.progress-label');
      
      icon.className = `progress-icon ${status}`;
      label.className = `progress-label ${status}`;
      
      if (status === 'complete') {
        icon.textContent = '✓';
      } else if (status === 'error') {
        icon.textContent = '✗';
      } else if (status === 'active') {
        icon.textContent = stepNum;
      }
      
      if (message) {
        const originalText = label.textContent.split(' - ')[0];
        label.textContent = `${originalText} - ${message}`;
      }
    }
    
    function setConvertButtonLoading(loading) {
      const btn = document.getElementById('convertBtn');
      const btnText = document.getElementById('convertBtnText');
      
      if (loading) {
        btn.classList.add('loading');
        btn.disabled = true;
        btnText.textContent = '';
        
        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        spinner.id = 'btnSpinner';
        btn.insertBefore(spinner, btnText);
        
        btnText.textContent = '변환 중...';
      } else {
        btn.classList.remove('loading');
        btn.disabled = false;
        
        const spinner = document.getElementById('btnSpinner');
        if (spinner) spinner.remove();
        
        btnText.textContent = '변환하기';
      }
    }
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function downloadMML() {
  if (!convertedMML) return;

  let defaultName = 'converted_mml.txt';
  if (uploadedFile) {
    const originalName = uploadedFile.name.replace(/\.(xml|musicxml|mxl)$/i, '');
    defaultName = `${originalName}_mml.txt`;
  }

  const fileName = prompt('파일명을 입력하세요', defaultName);
  if (!fileName) return;

  const blob = new Blob([convertedMML], { type: 'text/plain;charset=utf-8' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = fileName.endsWith('.txt') ? fileName : fileName + '.txt';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  URL.revokeObjectURL(link.href);
}
    
    
function displayPreview(mmlText) {
  const previewContainer = document.getElementById('previewContainer');
  const channels = mmlText.trim().split('\n\n\n\n');
  channelOriginalContents = {};

  if (channels.length > 0 && channels[0].trim()) {
    let channelsHtml = '<div class="preview-channels">';

    channels.forEach((channel, index) => {
      const lines = channel.trim().split('\n');
      if (lines.length === 0) return;

      let titleLine = lines[0];
      let tempoCommand = '';

      const tempoMatch = titleLine.match(/#\s*T(\d+)/);
      if (tempoMatch) {
        tempoCommand = `T${tempoMatch[1]}`;
        titleLine = titleLine.replace(/#\s*T\d+/, '').replace(/\s+#\s*$/, '').trim();
      }

      const contentLines = lines.slice(1);

      if (tempoCommand && contentLines.length > 0) {
        contentLines[0] = tempoCommand + ' ' + contentLines[0];
      }

      // 원본 저장
      channelOriginalContents[index] = contentLines.join('\n');

      const highlightedContent = contentLines.map(line => {
        if (line.includes('# 경고:')) {
          return `<span class="error-line">${line}</span>`;
        }
        return line;
      }).join('\n');

      if (!highlightedContent.trim()) return;

      const charCount = contentLines
        .filter(line => !line.startsWith('#'))
        .join('')
        .replace(/\s/g, '')
        .length;

      channelsHtml += `
        <div class="preview-channel">
          <div class="preview-channel-header">
            <div class="preview-channel-title">${titleLine}</div>
            <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#666;cursor:pointer;margin-right:16px;">
  <input type="checkbox" class="space-remove-cb" data-channel-index="${index}" style="width:14px;height:14px;cursor:pointer;accent-color:#1741EA;" onchange="toggleSpaceRemove(${index}, this.checked)">
  공백 지우기
</label>
            <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#666;cursor:pointer;margin-right:16px;">
              <input type="checkbox" class="rest-optimize-cb" data-channel-index="${index}" style="width:14px;height:14px;cursor:pointer;" onchange="toggleRestOptimize(${index}, this.checked)">
              쉼표 병합
            </label>
            <label style="display:flex;align-items:center;gap:8px;font-size:12px;color:#666;cursor:pointer;margin-right:16px;">
  볼륨
  <button style="width:22px;height:22px;border:1px solid #d0d0d0;border-radius:3px;background:#fcfcfc;cursor:pointer;font-size:12px;line-height:1;padding:0;" onclick="changeVolume(${index}, -1)">−</button>
  <span class="volume-offset-display" data-channel-index="${index}" style="min-width:14px;text-align:center;font-size:12px;">0</span>
  <button style="width:22px;height:22px;border:1px solid #d0d0d0;border-radius:3px;background:#fcfcfc;cursor:pointer;font-size:12px;line-height:1;padding:0;" onclick="changeVolume(${index}, +1)">+</button>
</label>
            <button class="copy-btn" onclick="copyChannelContent(${index})" title="복사">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
          <div class="preview-channel-content" data-channel-index="${index}">${highlightedContent}</div>
          <div class="preview-channel-footer">공백 제외 ${charCount}자</div>
        </div>
      `;
    });

    channelsHtml += '</div>';
    previewContainer.innerHTML = channelsHtml;
  } else {
    previewContainer.innerHTML = '<div class="preview-empty">변환 결과가 없습니다</div>';
  }
}
    
    window.copyChannelContent = function(channelIndex) {
      const channelContent = document.querySelector(`.preview-channel-content[data-channel-index="${channelIndex}"]`);
      if (!channelContent) return;
      
      const textContent = channelContent.textContent;
      
      navigator.clipboard.writeText(textContent).then(() => {
        const btn = document.querySelectorAll('.copy-btn')[channelIndex];
        const originalHTML = btn.innerHTML;
        
        btn.innerHTML = `
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20 6 9 17 4 12"></polyline>
          </svg>
        `;
        
        setTimeout(() => {
          btn.innerHTML = originalHTML;
        }, 1000);
      }).catch(err => {
        console.error('복사 실패:', err);
        alert('복사에 실패했습니다.');
      });
    };

    
window.applyChannelOptions = function(channelIndex) {
  const contentEl = document.querySelector(`.preview-channel-content[data-channel-index="${channelIndex}"]`);
  if (!contentEl) return;

  const original = channelOriginalContents[channelIndex];
  if (!original) return;

  let text = original;

  const restCb = document.querySelector(`.rest-optimize-cb[data-channel-index="${channelIndex}"]`);
  if (restCb && restCb.checked) {
    text = optimizeRests(text);
  }

  const volDisplay = document.querySelector(`.volume-offset-display[data-channel-index="${channelIndex}"]`);
  const volOffset = volDisplay ? parseInt(volDisplay.textContent) : 0;
  if (volOffset !== 0) {
    text = adjustVolume(text, volOffset);
  }

  const spaceCb = document.querySelector(`.space-remove-cb[data-channel-index="${channelIndex}"]`);
  if (spaceCb && spaceCb.checked) {
    const lines = text.split('\n');
    text = lines
      .filter(line => !line.trim().startsWith('#'))
      .map(line => line.replace(/ +/g, ''))
      .join('');
  }

  contentEl.textContent = text;

  const charCount = text.split('\n')
    .filter(line => !line.startsWith('#'))
    .join('')
    .replace(/\s/g, '')
    .length;
  const footer = contentEl.closest('.preview-channel').querySelector('.preview-channel-footer');
  if (footer) footer.textContent = '공백 제외 ' + charCount + '자';
};

window.changeVolume = function(channelIndex, delta) {
  const display = document.querySelector(`.volume-offset-display[data-channel-index="${channelIndex}"]`);
  if (!display) return;

  const current = parseInt(display.textContent) || 0;
  const newValue = Math.max(-15, Math.min(15, current + delta));
  display.textContent = newValue;

  applyChannelOptions(channelIndex);
};

window.toggleRestOptimize = function(channelIndex, checked) {
  applyChannelOptions(channelIndex);
};

window.toggleSpaceRemove = function(channelIndex, checked) {
  applyChannelOptions(channelIndex);
};



    // 유틸리티 함수들
    function parseMMLDuration(mmlNote) {
      const match = mmlNote.match(/(\d+)(\.)?$/);
      if (!match) return 0;
      
      const length = parseInt(match[1]);
      const hasDot = !!match[2];
      
      let quarters = 4 / length;
      if (hasDot) quarters *= 1.5;
      
      return quarters;
    }
    
    function calculateActualMeasureDuration(measureNotes) {
      let totalDuration = 0;
      
      for (const note of measureNotes) {
        if (note.startsWith('#') || note.startsWith('V') || note.startsWith('T') || 
            note === '>' || note === '<' || note === 'L4') {
          continue;
        }
        
        if (note.includes('&')) {
          const parts = note.split('&');
          for (const part of parts) {
            totalDuration += parseMMLDuration(part);
          }
        } else {
          totalDuration += parseMMLDuration(note);
        }
      }
      
      return totalDuration;
    }
    
    function getMidiNumber(step, octave, alter) {
      const noteMap = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
      let midiNum = (octave + 1) * 12 + (noteMap[step] || 0);
      if (alter === '1') midiNum += 1;
      if (alter === '-1') midiNum -= 1;
      return midiNum;
    }
    
    function isSameNote(note1, note2) {
      if (!note1 || !note2) return false;
      return note1.step === note2.step && 
             note1.alter === note2.alter && 
             note1.octave === note2.octave;
    }
    
    function splitDurationToMML(durationInQuarters) {
      const parts = [];
      let remaining = durationInQuarters;
      
      const durations = [
        {quarter: 4, mml: '1'},
        {quarter: 3, mml: '2.'},
        {quarter: 2, mml: '2'},
        {quarter: 1.5, mml: '4.'},
        {quarter: 1, mml: '4'},
        {quarter: 0.75, mml: '8.'},
        {quarter: 0.5, mml: '8'},
        {quarter: 0.25, mml: '16'},
        {quarter: 0.125, mml: '32'},
        {quarter: 0.0625, mml: '64'}
      ];
      
      for (const d of durations) {
        while (remaining >= d.quarter - 0.001) {
          parts.push(d.mml);
          remaining -= d.quarter;
        }
      }
      
      if (parts.length === 0) {
        throw new Error(`음표 길이를 MML로 변환할 수 없습니다: ${durationInQuarters} quarter notes`);
      }
      
      return parts;
    }
    
    function hasMoreTies(note) {
      const ties = note.querySelectorAll('tie');
      let hasStop = false;
      let hasStart = false;
      
      ties.forEach(tie => {
        if (tie.getAttribute('type') === 'stop') hasStop = true;
        if (tie.getAttribute('type') === 'start') hasStart = true;
      });
      
      return hasStop && hasStart;
    }
    
    function convertDurationToMML(durationInQuarters) {
      if (durationInQuarters >= 16) {
        const numWholes = Math.floor(durationInQuarters / 4);
        const remainder = durationInQuarters - (numWholes * 4);
        const rests = [];
        for (let i = 0; i < numWholes; i++) {
          rests.push('R1');
        }
        if (remainder > 0.01) {
          rests.push(...convertDurationToMML(remainder));
        }
        return rests;
      }
      
      if (durationInQuarters === 6) return ['R1', 'R2'];
      if (durationInQuarters === 4) return ['R1'];
      if (durationInQuarters === 3) return ['R2', 'R4'];
      if (durationInQuarters === 2) return ['R2'];
      if (durationInQuarters === 1.5) return ['R4', 'R8'];
      if (durationInQuarters === 1) return ['R4'];
      if (durationInQuarters === 0.75) return ['R8', 'R16'];
      if (durationInQuarters === 0.5) return ['R8'];
      if (durationInQuarters === 0.25) return ['R16'];
      if (durationInQuarters === 0.125) return ['R32'];
      
      const numQuarters = Math.floor(durationInQuarters);
      const remainder = durationInQuarters - numQuarters;
      const rests = [];
      
      for (let i = 0; i < numQuarters; i++) {
        rests.push('R4');
      }
      
      if (remainder > 0.01) {
        if (remainder >= 0.75) {
          rests.push('R8', 'R16');
        } else if (remainder >= 0.5) {
          rests.push('R8');
        } else if (remainder >= 0.25) {
          rests.push('R16');
        } else if (remainder >= 0.125) {
          rests.push('R32');
        }
      }
      
      return rests.length > 0 ? rests : ['R4'];
    }
    
    function convertDurationToTripletMML(durationInQuarters) {
      const rests = [];
      let remaining = durationInQuarters;
      
      const tripletDurations = [
        { quarter: 4/6, mml: 'R6' },
        { quarter: 4/12, mml: 'R12' },
        { quarter: 4/24, mml: 'R24' },
        { quarter: 4/48, mml: 'R48' }
      ];
      
      for (const d of tripletDurations) {
        while (remaining >= d.quarter - 0.001) {
          rests.push(d.mml);
          remaining -= d.quarter;
        }
      }
      
      if (remaining > 0.001) {
        rests.push('R48');
      }
      
      return rests.length > 0 ? rests : ['R24'];
    }
    
    function hasAccent(note) {
      const articulations = note.querySelector('articulations');
      if (!articulations) return false;
      
      return !!(articulations.querySelector('accent') || articulations.querySelector('strong-accent'));
    }
    
    function hasStaccato(note) {
      const articulations = note.querySelector('articulations');
      if (!articulations) return false;
      
      return !!articulations.querySelector('staccato');
    }
    
    function calculateNoteDuration(note) {
      const duration = note.querySelector('type')?.textContent;
      const dots = note.querySelectorAll('dot');
      const timeModification = note.querySelector('time-modification');
      
      let durationInQuarters = 0;
      
      if (timeModification) {
        const actualNotes = parseInt(timeModification.querySelector('actual-notes')?.textContent || '3');
        const normalNotes = parseInt(timeModification.querySelector('normal-notes')?.textContent || '2');
        
        if (actualNotes === 3 && normalNotes === 2) {
          if (duration === 'quarter') durationInQuarters = 4/6;
          else if (duration === 'eighth') durationInQuarters = 4/12;
          else if (duration === '16th') durationInQuarters = 4/24;
          else if (duration === '32nd') durationInQuarters = 4/48;
        } else {
          let baseDuration = 0;
          if (duration === 'whole') baseDuration = 4;
          else if (duration === 'half') baseDuration = 2;
          else if (duration === 'quarter') baseDuration = 1;
          else if (duration === 'eighth') baseDuration = 0.5;
          else if (duration === '16th') baseDuration = 0.25;
          else if (duration === '32nd') baseDuration = 0.125;
          else if (duration === '64th') baseDuration = 0.0625;
          else if (duration === '128th') baseDuration = 0.03125;
          
          durationInQuarters = baseDuration * (normalNotes / actualNotes);
        }
      } else {
        if (duration === 'whole') durationInQuarters = 4;
        else if (duration === 'half') durationInQuarters = 2;
        else if (duration === 'quarter') durationInQuarters = 1;
        else if (duration === 'eighth') durationInQuarters = 0.5;
        else if (duration === '16th') durationInQuarters = 0.25;
        else if (duration === '32nd') durationInQuarters = 0.125;
        else if (duration === '64th') durationInQuarters = 0.0625;
        else if (duration === '128th') durationInQuarters = 0.03125;
      }
      
      if (dots.length > 0 && durationInQuarters > 0) {
        if (dots.length === 1) {
          durationInQuarters *= 1.5;  // 단점: 1.5배
        } else if (dots.length === 2) {
          durationInQuarters *= 1.75;  // 겸점: 1.75배 (1 + 0.5 + 0.25)
        } else if (dots.length >= 3) {
          // 삼점 이상은 드물지만 지원
          let multiplier = 1;
          for (let i = 0; i < dots.length; i++) {
            multiplier += Math.pow(0.5, i + 1);
          }
          durationInQuarters *= multiplier;
        }
      }
      
      if (durationInQuarters === 0) {
        throw new Error(`지원하지 않는 음표 길이입니다: ${duration || '알 수 없음'}. 변환할 수 없습니다.`);
      }
      
      return durationInQuarters;
    }
    
    function isNonTripletTuplet(note) {
      const timeModification = note.querySelector('time-modification');
      if (!timeModification) return false;
      
      const actual = parseInt(timeModification.querySelector('actual-notes')?.textContent || '0');
      const normal = parseInt(timeModification.querySelector('normal-notes')?.textContent || '0');
      
      return !(actual === 3 && normal === 2) && actual > 0 && normal > 0;
    }
    
    // 조성, 다이나믹스 관련 함수들
    function getKeySignature(partElement) {
      const firstMeasure = partElement.querySelector('measure');
      if (!firstMeasure) return { fifths: 0, alterations: {} };
      
      const attributes = firstMeasure.querySelector('attributes');
      if (!attributes) return { fifths: 0, alterations: {} };
      
      const keyElement = attributes.querySelector('key');
      if (!keyElement) return { fifths: 0, alterations: {} };
      
      const fifths = parseInt(keyElement.querySelector('fifths')?.textContent || '0');
      
      return calculateKeyAlterations(fifths);
    }
    
    function calculateKeyAlterations(fifths) {
      const sharps = ['F', 'C', 'G', 'D', 'A', 'E', 'B'];
      const flats = ['B', 'E', 'A', 'D', 'G', 'C', 'F'];
      
      const alterations = {};
      
      if (fifths > 0) {
        for (let i = 0; i < fifths && i < sharps.length; i++) {
          alterations[sharps[i]] = 1;
        }
      } else if (fifths < 0) {
        for (let i = 0; i < Math.abs(fifths) && i < flats.length; i++) {
          alterations[flats[i]] = -1;
        }
      }
      
      return { fifths, alterations };
    }
    
    function updateKeySignature(measure, currentKeySignature) {
      const attributes = measure.querySelector('attributes');
      if (!attributes) return currentKeySignature;
      
      const keyElement = attributes.querySelector('key');
      if (!keyElement) return currentKeySignature;
      
      const fifths = parseInt(keyElement.querySelector('fifths')?.textContent || '0');
      return calculateKeyAlterations(fifths);
    }
    
    function collectDynamics(partElement) {
      const dynamicsSet = new Set();
      const measures = partElement.querySelectorAll('measure');
      
      measures.forEach(measure => {
        const directions = measure.querySelectorAll('direction');
        directions.forEach(direction => {
          const dynamics = direction.querySelector('dynamics');
          if (dynamics) {
            for (const child of dynamics.children) {
              dynamicsSet.add(child.tagName);
            }
          }
        });
      });
      
      return Array.from(dynamicsSet);
    }
    
    function mapDynamicsToVolume(dynamics, dynamicsList) {
      const strengthOrder = ['ppp', 'pp', 'p', 'mp', 'mf', 'f', 'ff', 'fff', 'ffff'];
      
      if (dynamics === 'mp') return 12;
if (dynamics === 'p') return 10;
if (['pp', 'ppp'].includes(dynamics)) return 8;
      
      const strongDynamics = dynamicsList.filter(d => {
        const idx = strengthOrder.indexOf(d);
        return idx >= strengthOrder.indexOf('mf');
      });
      
      if (strongDynamics.length === 0) {
        return 14;
      }

      if (dynamics === 'mf') return 14;
      
      strongDynamics.sort((a, b) => {
        return strengthOrder.indexOf(b) - strengthOrder.indexOf(a);
      });
      
      const index = strongDynamics.indexOf(dynamics);
      if (index === -1) {
        return 13;
      }
      
      return Math.max(13, 15 - index);
    }
    
    function getMeasureDynamicsMap(measure) {
      const dynamicsMap = new Map();
      const children = Array.from(measure.children);
      
      let currentDynamics = null;
      
      children.forEach((child) => {
        if (child.tagName === 'direction') {
          const dynamics = child.querySelector('dynamics');
          if (dynamics && dynamics.children.length > 0) {
            currentDynamics = dynamics.children[0].tagName;
          }
        } else if (child.tagName === 'note') {
          if (currentDynamics) {
            dynamicsMap.set(child, currentDynamics);
          }
        }
      });
      
      return { map: dynamicsMap, lastDynamics: currentDynamics };
    }
    
    function getCurrentDynamics(measure, currentDynamics) {
      const directions = measure.querySelectorAll('direction');
      
      for (const direction of directions) {
        const dynamics = direction.querySelector('dynamics');
        if (dynamics && dynamics.children.length > 0) {
          return dynamics.children[0].tagName;
        }
      }
      
      return currentDynamics;
    }
    
    function getAccentDynamic(measure) {
  const directions = measure.querySelectorAll('direction');
  
  for (const direction of directions) {
    const dynamics = direction.querySelector('dynamics');
    if (dynamics) {
      if (dynamics.querySelector('fp')) return 'fp';
      if (dynamics.querySelector('sfz') || dynamics.querySelector('sffz') ||
          dynamics.querySelector('sf') || dynamics.querySelector('fz') ||
          dynamics.querySelector('rfz')) return 'sfz';
    }
  }
  
  return null;
}
    
    function getTrillUpperNote(step, alter, octave, keySignature, trillAlter) {
      const noteSequence = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const currentIndex = noteSequence.indexOf(step);
      
      let nextIndex = (currentIndex + 1) % 7;
      let nextStep = noteSequence[nextIndex];
      let octaveChange = 0;
      
      if (step === 'B' && nextStep === 'C') {
        octaveChange = 1;
      }
      
      if (trillAlter) {
        if (trillAlter === 'sharp') return { note: nextStep + '+', octaveChange };
        if (trillAlter === 'flat') return { note: nextStep + '-', octaveChange };
        return { note: nextStep, octaveChange };
      }
      
      const nextAlter = keySignature.alterations?.[nextStep] || 0;
      
      if (nextAlter === 1) return { note: nextStep + '+', octaveChange };
      if (nextAlter === -1) return { note: nextStep + '-', octaveChange };
      return { note: nextStep, octaveChange };
    }
    
    function getStaffCount(partElement) {
      const measures = partElement.querySelectorAll('measure');
      let maxStaff = 1;
      
      measures.forEach(measure => {
        const notes = measure.querySelectorAll('note');
        notes.forEach(note => {
          const staff = note.querySelector('staff');
          if (staff) {
            maxStaff = Math.max(maxStaff, parseInt(staff.textContent));
          }
        });
      });
      
      return maxStaff;
    }
    
    function getStaffStartMeasure(partElement, staffNum) {
      const measures = partElement.querySelectorAll('measure');
      
      for (let i = 0; i < measures.length; i++) {
        const notes = measures[i].querySelectorAll('note');
        for (const note of notes) {
          const staff = note.querySelector('staff');
          const noteStaff = staff ? parseInt(staff.textContent) : 1;
          
          if (noteStaff === staffNum) {
            const pitch = note.querySelector('pitch');
            const unpitched = note.querySelector('unpitched');
            if (pitch || unpitched) {
              return i;
            }
          }
        }
      }
      
      return 0;
    }
    
    function findFirstPitchInStaff(measure, staffNum) {
      const notes = measure.querySelectorAll('note');
      
      for (const note of notes) {
        const staff = note.querySelector('staff');
        const noteStaff = staff ? parseInt(staff.textContent) : 1;
        if (noteStaff !== staffNum) continue;
        
        const chord = note.querySelector('chord');
        if (chord) continue;
        
        const rest = note.querySelector('rest');
        if (rest) continue;
        
        const pitch = note.querySelector('pitch');
        if (pitch) {
          const step = pitch.querySelector('step')?.textContent;
          const octave = parseInt(pitch.querySelector('octave')?.textContent || '4');
          const alterElem = pitch.querySelector('alter');
          const alter = alterElem ? alterElem.textContent : null;
          
          return { step, octave, alter };
        }
      }
      
      return null;
    }
    
    function extractRepresentativePitches(partElement) {
      const measures = partElement.querySelectorAll('measure');
      const pitchMap = new Map();
      const staffCount = getStaffCount(partElement);
      
      let lastPitch = { step: 'C', octave: 4, alter: null };
      
      measures.forEach((measure, index) => {
        let foundPitch = null;
        
        foundPitch = findFirstPitchInStaff(measure, 1);
        
        if (!foundPitch) {
          for (let staffNum = 2; staffNum <= staffCount; staffNum++) {
            foundPitch = findFirstPitchInStaff(measure, staffNum);
            if (foundPitch) break;
          }
        }
        
        if (foundPitch) {
          lastPitch = foundPitch;
          pitchMap.set(index, foundPitch);
        } else {
          pitchMap.set(index, lastPitch);
        }
      });
      
      return pitchMap;
    }
    
    function getTimeSignature(measure) {
      const attributes = measure.querySelector('attributes');
      if (!attributes) return null;
      
      const time = attributes.querySelector('time');
      if (!time) return null;
      
      const beats = parseInt(time.querySelector('beats')?.textContent || '4');
      const beatType = parseInt(time.querySelector('beat-type')?.textContent || '4');
      
      return { beats, beatType };
    }
    
    function calculateMeasureDuration(measure, currentTimeSignature) {
      const timeSignature = getTimeSignature(measure) || currentTimeSignature;
      
      if (!timeSignature) {
        return { duration: 4, timeSignature: { beats: 4, beatType: 4 } };
      }
      
      const durationInQuarters = (timeSignature.beats * 4) / timeSignature.beatType;
      return { duration: durationInQuarters, timeSignature };
    }
    
    function expandMeasuresWithRepeats(measures) {
  const expanded = [];
  const originalIndexMap = new Map();
  const expandOrder = [];
  const repeatStack = [];

  const hasBackward = measures.some(m => m.querySelector('repeat[direction="backward"]'));
  const hasForward = measures.some(m => m.querySelector('repeat[direction="forward"]'));

  if (hasBackward && !hasForward) {
    repeatStack.push({
      start: 0,
      firstEndingIndices: [],
      firstEndingOriginalIndices: [],
      secondEndingIndices: [],
      inFirstEnding: false,
      inSecondEnding: false,
    });
  }

  for (let i = 0; i < measures.length; i++) {
    const measure = measures[i];

    const measureRepeat = measure.querySelector('measure-repeat[type="start"]');
    if (measureRepeat && expanded.length > 0) {
      const repeatCount = parseInt(measureRepeat.textContent || '1');
      for (let r = 0; r < repeatCount; r++) {
        const prevMeasure = expanded[expanded.length - 1];
        expanded.push(prevMeasure);
        const prevOrigIdx = originalIndexMap.get(expanded.length - 2);
        originalIndexMap.set(expanded.length - 1, prevOrigIdx);
        expandOrder.push(prevOrigIdx);
      }
      continue;
    }

    const forwardRepeat = measure.querySelector('repeat[direction="forward"]');
    if (forwardRepeat) {
      repeatStack.push({
        start: expanded.length,
        firstEndingIndices: [],
        firstEndingOriginalIndices: [],
        secondEndingIndices: [],
        inFirstEnding: false,
        inSecondEnding: false,
      });
    }

    const endingStart = measure.querySelector('ending[type="start"]');
    if (endingStart && repeatStack.length > 0) {
      const endingNumber = endingStart.getAttribute('number');
      const repeatInfo = repeatStack[repeatStack.length - 1];

      if (endingNumber === '1') {
        repeatInfo.inFirstEnding = true;
        repeatInfo.inSecondEnding = false;
      } else if (endingNumber === '2' || endingNumber === '3') {
        repeatInfo.inFirstEnding = false;
        repeatInfo.inSecondEnding = true;
      }
    }

    expanded.push(measure);
    originalIndexMap.set(expanded.length - 1, i);
    expandOrder.push(i);

    if (repeatStack.length > 0) {
      const repeatInfo = repeatStack[repeatStack.length - 1];
      if (repeatInfo.inFirstEnding) {
        repeatInfo.firstEndingIndices.push(expanded.length - 1);
        repeatInfo.firstEndingOriginalIndices.push(i);
      } else if (repeatInfo.inSecondEnding) {
        repeatInfo.secondEndingIndices.push(expanded.length - 1);
      }
    }

    const endingStop = measure.querySelector('ending[type="stop"], ending[type="discontinue"]');
    if (endingStop && repeatStack.length > 0) {
      const endingNumber = endingStop.getAttribute('number');
      const repeatInfo = repeatStack[repeatStack.length - 1];
      if (endingNumber === '1') {
        repeatInfo.inFirstEnding = false;
      } else if (endingNumber === '2' || endingNumber === '3') {
        repeatInfo.inSecondEnding = false;
      }
    }

    const backwardRepeat = measure.querySelector('repeat[direction="backward"]');
    if (backwardRepeat) {
      let repeatInfo;

      if (repeatStack.length > 0) {
        repeatInfo = repeatStack.pop();
      } else {
        repeatInfo = {
          start: 0,
          firstEndingIndices: [],
          firstEndingOriginalIndices: [],
          secondEndingIndices: [],
          inFirstEnding: false,
          inSecondEnding: false,
        };
      }

      const repeatEndIdx = repeatInfo.firstEndingIndices.length > 0
        ? repeatInfo.firstEndingIndices[0] - 1
        : expanded.length - 1;

      for (let j = repeatInfo.start; j <= repeatEndIdx; j++) {
        expanded.push(expanded[j]);
        const origIdx = originalIndexMap.get(j);
        originalIndexMap.set(expanded.length - 1, origIdx);
        expandOrder.push(origIdx);
      }
    }
  }

  return { measures: expanded, originalIndexMap, expandOrder };
}

function applyExpandOrder(measuresArray, expandOrder) {
  const expanded = [];
  const originalIndexMap = new Map();

  for (let i = 0; i < expandOrder.length; i++) {
    const origIdx = expandOrder[i];
    expanded.push(measuresArray[origIdx]);
    originalIndexMap.set(i, origIdx);
  }

  return { measures: expanded, originalIndexMap, expandOrder };
}
    
    function findDivisions(currentMeasure, partElement) {
      let divisionsElem = currentMeasure.querySelector('attributes divisions');
      if (divisionsElem) {
        return parseInt(divisionsElem.textContent);
      }
      
      const allMeasures = Array.from(partElement.querySelectorAll('measure'));
      const currentIndex = allMeasures.indexOf(currentMeasure);
      
      for (let i = currentIndex - 1; i >= 0; i--) {
        divisionsElem = allMeasures[i].querySelector('attributes divisions');
        if (divisionsElem) {
          return parseInt(divisionsElem.textContent);
        }
      }
      
      return 1;
    }
    
    // NoteProcessor 클래스
    class NoteProcessor {
      constructor(keySignature, dynamicsList) {
        this.keySignature = keySignature;
        this.dynamicsList = dynamicsList;
      }
      
      findLastNoteableMeasure(measures, originalIndexMap, staffNum, staffStartMeasure, voiceNum = 1) {
        for (let i = measures.length - 1; i >= 0; i--) {
          const originalIndex = originalIndexMap.get(i);
          if (originalIndex < staffStartMeasure) continue;
          
          const notes = measures[i].querySelectorAll('note');
          let hasRealNote = false;
          
          for (const note of notes) {
            const staff = note.querySelector('staff');
            const noteStaff = staff ? parseInt(staff.textContent) : 1;
            if (noteStaff !== staffNum) continue;
            
            if (voiceNum !== null && voiceNum !== 'any') {
              const voice = note.querySelector('voice');
              const noteVoiceNum = voice ? parseInt(voice.textContent) : 1;
              if (noteVoiceNum !== voiceNum) continue;
            }
            
            const grace = note.querySelector('grace');
            if (grace) continue;
            
            const rest = note.querySelector('rest');
            const pitch = note.querySelector('pitch');
            const unpitched = note.querySelector('unpitched');
            
            if (pitch || unpitched) {
              hasRealNote = true;
              break;
            }
          }
          
          if (hasRealNote) {
            return i;
          }
        }
        return -1;
      }
      
      getGraceDuration(note) {
        const ornaments = note.querySelector('ornaments');
        if (ornaments) {
          const hasUnsupportedOrnament = 
            ornaments.querySelector('turn') ||
            ornaments.querySelector('mordent') ||
            ornaments.querySelector('inverted-mordent');
          
          if (hasUnsupportedOrnament) {
            return null;
          }
        }
        
        return 0.125;
      }
      
      extractNoteInfo(note, representativePitchMap, originalIndex) {
        const pitch = note.querySelector('pitch');
        const unpitched = note.querySelector('unpitched');
        
        let step, octave, alter;
        
        if (pitch) {
          step = pitch.querySelector('step')?.textContent;
          octave = parseInt(pitch.querySelector('octave')?.textContent || '4');
          const alterElem = pitch.querySelector('alter');
          alter = alterElem ? alterElem.textContent : null;
        } else if (unpitched) {
          const representativePitch = representativePitchMap.get(originalIndex);
          if (representativePitch) {
            step = representativePitch.step;
            octave = representativePitch.octave;
            alter = representativePitch.alter;
          } else {
            step = 'C';
            octave = 4;
            alter = null;
          }
        } else {
          return null;
        }
        
        if (!step || step.trim() === '') return null;
        
        let noteName = step;
        if (alter === '1') noteName += '+';
        if (alter === '-1') noteName += '-';
        
        return { step, octave, alter, noteName };
      }
      
      calculateLength(note, graceNoteDuration = 0) {
  const duration = note.querySelector('type')?.textContent;
  const dots = note.querySelectorAll('dot');
  const timeModification = note.querySelector('time-modification');
  let length = '';
  
  let adjustedDuration = null;
  if (graceNoteDuration > 0) {
    const originalDuration = calculateNoteDuration(note);
    const remainingDuration = originalDuration - graceNoteDuration;
    
    if (remainingDuration > 0.001) {
      adjustedDuration = remainingDuration;
    } else {
      length = '32';
    }
  }
  
  if (!adjustedDuration) {
    if (timeModification) {
      const actualNotes = parseInt(timeModification.querySelector('actual-notes')?.textContent || '3');
      const normalNotes = parseInt(timeModification.querySelector('normal-notes')?.textContent || '2');
      
      if (actualNotes === 3 && normalNotes === 2) {
        if (duration === 'half') length = '3';
        else if (duration === 'quarter') length = '6';
        else if (duration === 'eighth') length = '12';
        else if (duration === '16th') length = '24';
        else if (duration === '32nd') length = '48';
      } else {
        let baseLength = 0;
        if (duration === 'whole') baseLength = 1;
        else if (duration === 'half') baseLength = 2;
        else if (duration === 'quarter') baseLength = 4;
        else if (duration === 'eighth') baseLength = 8;
        else if (duration === '16th') baseLength = 16;
        else if (duration === '32nd') baseLength = 32;
        else if (duration === '64th') baseLength = 64;
        else if (duration === '128th') baseLength = 128;
        
        const extendedLength = Math.max(1, Math.round(baseLength / normalNotes));
        length = extendedLength.toString();
      }
    } else {
      if (duration === 'whole') length = '1';
      else if (duration === 'half') length = '2';
      else if (duration === 'quarter') length = '4';
      else if (duration === 'eighth') length = '8';
      else if (duration === '16th') length = '16';
      else if (duration === '32nd') length = '32';
      else if (duration === '64th') length = '64';
      else if (duration === '128th') length = '128';
    }
  }
  
  // 점 처리
  if (dots.length === 1 && length) {
    length += '.';
  } else if (dots.length >= 2 && length) {
    const lengthNum = parseInt(length);
    let baseDuration = 0;
    
    const isTriplet = ['3', '6', '12', '24', '48'].includes(length);
    
    if (isTriplet) {
      const baseLength = lengthNum / 3;
      baseDuration = 4 / baseLength;
    } else {
      baseDuration = 4 / lengthNum;
    }
    
    let multiplier = 1;
    for (let i = 0; i < dots.length; i++) {
      multiplier += Math.pow(0.5, i + 1);
    }
    
    adjustedDuration = baseDuration * multiplier;
    length = null;
  }
  
  return { length, adjustedDuration };
}
      
      processStaccato(noteName, length, adjustedDuration) {
        const originalDuration = adjustedDuration || (length ? parseMMLDuration(noteName + length) : 1);
        
        const isTriplet = length && ['6', '12', '24', '48'].includes(length.replace('.', ''));
        
        let staccatoLength = '16';
        let staccatoDuration = 0.25;
        
        if (isTriplet) {
          staccatoLength = '24';
          staccatoDuration = 4/24;
        }
        
        const restDuration = originalDuration - staccatoDuration;
        
        const result = [];
        result.push(noteName + staccatoLength);
        
        if (restDuration > 0.01) {
          if (isTriplet) {
            const tripletRests = convertDurationToTripletMML(restDuration);
            result.push(...tripletRests);
          } else {
            const restParts = convertDurationToMML(restDuration);
            result.push(...restParts);
          }
        }
        
        return result;
      }
      
      generateTrillMML(noteName, noteInfo, length, keySignature, trillAlter) {
        const lengthNum = parseInt(length.replace('.', '')) || 4;
        const isDotted = length.includes('.');
        
        let totalQuarters = 4 / lengthNum;
        if (isDotted) {
          totalQuarters *= 1.5;
        }
        
        let num32ndNotes = 32 / lengthNum;
        if (isDotted) {
          num32ndNotes *= 1.5;
        }
        const numPairs = Math.max(1, Math.floor(num32ndNotes / 2));
        
        const upperNoteInfo = getTrillUpperNote(noteInfo.step, noteInfo.alter, noteInfo.octave, keySignature, trillAlter);
        
        const mml = [];
        
        const trillNoteDuration = 4 / 32;
        const usedDuration = trillNoteDuration * 2 * (numPairs - 1);
        const lastPairDuration = totalQuarters - usedDuration;
        
        for (let i = 0; i < numPairs - 1; i++) {
          mml.push({ type: 'note', value: noteName + '32' });
          
          if (upperNoteInfo.octaveChange > 0) {
            for (let j = 0; j < upperNoteInfo.octaveChange; j++) {
              mml.push({ type: 'octave', value: '>' });
            }
          }
          
          mml.push({ type: 'note', value: upperNoteInfo.note + '32' });
          
          if (upperNoteInfo.octaveChange > 0) {
            for (let j = 0; j < upperNoteInfo.octaveChange; j++) {
              mml.push({ type: 'octave', value: '<' });
            }
          }
        }
        
        const lastNoteDuration = lastPairDuration / 2;
        
        if (lastNoteDuration > 0.01) {
          const lastNoteMMLParts = splitDurationToMML(lastNoteDuration);
          
          const firstTiedNotes = lastNoteMMLParts.map(part => noteName + part);
          mml.push({ type: 'note', value: firstTiedNotes.join('&') });
          
          if (upperNoteInfo.octaveChange > 0) {
            for (let j = 0; j < upperNoteInfo.octaveChange; j++) {
              mml.push({ type: 'octave', value: '>' });
            }
          }
          
          const secondTiedNotes = lastNoteMMLParts.map(part => upperNoteInfo.note + part);
          mml.push({ type: 'note', value: secondTiedNotes.join('&') });
          
          if (upperNoteInfo.octaveChange > 0) {
            for (let j = 0; j < upperNoteInfo.octaveChange; j++) {
              mml.push({ type: 'octave', value: '<' });
            }
          }
        }
        
        return mml;
      }
      
      generateTremoloMML(noteName, length, tremoloLines) {
        const lengthNum = parseInt(length.replace('.', '')) || 4;
        const isDotted = length.includes('.');
        
        const tremoloNoteLength = lengthNum * Math.pow(2, tremoloLines);
        
        let numRepeats = Math.pow(2, tremoloLines);
        if (isDotted) {
          numRepeats = Math.round(numRepeats * 1.5);
        }
        
        const mml = [];
        for (let i = 0; i < numRepeats; i++) {
          mml.push({ type: 'note', value: noteName + tremoloNoteLength });
        }
        
        return mml;
      }
      
      processTie(note, noteName, length, adjustedDuration, tiedNotes, lastNoteInfo, currentNoteInfo) {
        const tieStart = note.querySelector('tie[type="start"]');
        const tieStop = note.querySelector('tie[type="stop"]');
        const isSamePitch = isSameNote(lastNoteInfo, currentNoteInfo);
        
        let result = {
          mml: [],
          tiedNotes: [...tiedNotes],
          lastNoteInfo: lastNoteInfo,
          inTie: false
        };
        
        if (adjustedDuration) {
          const mmlParts = splitDurationToMML(adjustedDuration);
          const tiedNoteParts = mmlParts.map(part => noteName + part);
          
          if (tieStart) {
            if (result.tiedNotes.length > 0 && !isSamePitch) {
              result.mml.push(result.tiedNotes.join('&'));
              result.tiedNotes = [];
            }
            result.tiedNotes.push(...tiedNoteParts);
            result.lastNoteInfo = currentNoteInfo;
            result.inTie = true;
          } else if (tieStop) {
            if (isSamePitch && result.tiedNotes.length > 0) {
              result.tiedNotes.push(...tiedNoteParts);
              if (!hasMoreTies(note)) {
                result.mml.push(result.tiedNotes.join('&'));
                result.tiedNotes = [];
                result.lastNoteInfo = null;
                result.inTie = false;
              } else {
                result.lastNoteInfo = currentNoteInfo;
                result.inTie = true;
              }
            } else {
              if (result.tiedNotes.length > 0) {
                result.mml.push(result.tiedNotes.join('&'));
                result.tiedNotes = [];
                result.inTie = false;
              }
              result.mml.push(tiedNoteParts.join('&'));
              result.lastNoteInfo = currentNoteInfo;
            }
          } else {
            if (result.tiedNotes.length > 0) {
              result.mml.push(result.tiedNotes.join('&'));
              result.tiedNotes = [];
              result.inTie = false;
            }
            result.mml.push(tiedNoteParts.join('&'));
            result.lastNoteInfo = currentNoteInfo;
          }
        } else {
          const noteStr = noteName + (length || '');
          
          if (tieStart) {
            if (result.tiedNotes.length > 0 && !isSamePitch) {
              result.mml.push(result.tiedNotes.join('&'));
              result.tiedNotes = [];
            }
            result.tiedNotes.push(noteStr);
            result.lastNoteInfo = currentNoteInfo;
            result.inTie = true;
          } else if (tieStop) {
            if (isSamePitch && result.tiedNotes.length > 0) {
              result.tiedNotes.push(noteStr);
              if (!hasMoreTies(note)) {
                result.mml.push(result.tiedNotes.join('&'));
                result.tiedNotes = [];
                result.lastNoteInfo = null;
                result.inTie = false;
              } else {
                result.lastNoteInfo = currentNoteInfo;
                result.inTie = true;
              }
            } else {
              if (result.tiedNotes.length > 0) {
                result.mml.push(result.tiedNotes.join('&'));
                result.tiedNotes = [];
                result.inTie = false;
              }
              result.mml.push(noteStr);
              result.lastNoteInfo = currentNoteInfo;
            }
          } else {
            if (result.tiedNotes.length > 0) {
              result.mml.push(result.tiedNotes.join('&'));
              result.tiedNotes = [];
              result.inTie = false;
            }
            result.mml.push(noteStr);
            result.lastNoteInfo = currentNoteInfo;
          }
        }
        
        return result;
      }
      
      processRest(restNote, measure, partElement, currentTimeSignature = null) {
  try {
    const rest = restNote.querySelector('rest');
    if (rest && rest.getAttribute('measure') === 'yes') {
      if (currentTimeSignature) {
        const { beats, beatType } = currentTimeSignature;
        const restArray = [];
        const restLength = beatType.toString();
        for (let i = 0; i < beats; i++) {
          restArray.push('R' + restLength);
        }
        return restArray;
      } else {
        return ['R4', 'R4', 'R4', 'R4'];
      }
    }
    
    const restType = restNote.querySelector('type')?.textContent;
    
    if (!restType) {
      const durationValue = parseInt(restNote.querySelector('duration')?.textContent || '0');
      const divisions = findDivisions(measure, partElement);
      const durationInQuarters = durationValue / divisions;
      
      if (currentTimeSignature && durationInQuarters > 0) {
        const measureDuration = (currentTimeSignature.beats * 4) / currentTimeSignature.beatType;
        
        if (Math.abs(durationInQuarters - measureDuration) < 0.01) {
          const { beats, beatType } = currentTimeSignature;
          const restArray = [];
          const restLength = beatType.toString();
          for (let i = 0; i < beats; i++) {
            restArray.push('R' + restLength);
          }
          return restArray;
        }
      }
      
      if (durationInQuarters > 0) {
        return convertDurationToMML(durationInQuarters);
      } else {
        return ['R4'];
      }
    } else {
      const timeModification = restNote.querySelector('time-modification');
      
      if (timeModification) {
        const actualNotes = parseInt(timeModification.querySelector('actual-notes')?.textContent || '3');
        const normalNotes = parseInt(timeModification.querySelector('normal-notes')?.textContent || '2');
        
        if (actualNotes === 3 && normalNotes === 2) {
          if (restType === 'half') return ['R3'];
          else if (restType === 'quarter') return ['R6'];
          else if (restType === 'eighth') return ['R12'];
          else if (restType === '16th') return ['R24'];
          else if (restType === '32nd') return ['R48'];
        }
      }
      
      const restDuration = calculateNoteDuration(restNote);
      return convertDurationToMML(restDuration);
    }
  } catch (error) {
    console.warn('쉼표 처리 중 오류:', error);
    return ['R4'];
  }
}
    }
    
    
function adjustVolume(text, offset) {
  return text.replace(/V(\d+)/g, (match, num) => {
    const adjusted = Math.max(0, Math.min(15, parseInt(num) + offset));
    return 'V' + adjusted;
  });
}

function optimizeRests(text) {
  const lines = text.split('\n');
  const optimizedLines = [];
  let currentDefaultLength = '4';

  for (const line of lines) {
    if (!line.trim() || line.trim().startsWith('#')) {
      optimizedLines.push(line);
      continue;
    }

    const lMatch = line.match(/^L(\d+\.?)\s*/);
    if (lMatch) {
      currentDefaultLength = lMatch[1];
    }

    const tokens = line.split(/\s+/);
    const newTokens = [];
    let restAccum = 0;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];

      if (isRestToken(token)) {
        restAccum += getRestDuration(token, currentDefaultLength);
      } else {
        if (restAccum > 0.001) {
          const optimizedRests = durationToOptimalRests(restAccum);
          newTokens.push(...optimizedRests);
          restAccum = 0;
        }

        const lCmd = token.match(/^L(\d+\.?)$/);
        if (lCmd) {
          currentDefaultLength = lCmd[1];
        }

        newTokens.push(token);
      }
    }

    if (restAccum > 0.001) {
      const optimizedRests = durationToOptimalRests(restAccum);
      newTokens.push(...optimizedRests);
    }

    optimizedLines.push(newTokens.join(' '));
  }

  return optimizedLines.join('\n');
}

function isRestToken(token) {
  return /^R(\d+\.?)?$/.test(token);
}

function getRestDuration(token, defaultLength) {
  const match = token.match(/^R(\d+\.?)?$/);
  if (!match) return 0;

  let lengthStr = match[1] || defaultLength;
  const hasDot = lengthStr.includes('.');
  const lengthNum = parseInt(lengthStr.replace('.', ''));

  if (lengthNum === 0) return 0;

  let duration = 4 / lengthNum;
  if (hasDot) duration *= 1.5;

  return duration;
}

function durationToOptimalRests(duration) {
  const rests = [];
  let remaining = duration;

  const restValues = [
    { dur: 4,      str: 'R1' },
    { dur: 2,      str: 'R2' },
    { dur: 1,      str: 'R4' },
    { dur: 0.5,    str: 'R8' },
    { dur: 0.25,   str: 'R16' },
    { dur: 0.125,  str: 'R32' },
    { dur: 0.0625, str: 'R64' },
  ];

  for (const rv of restValues) {
    while (remaining >= rv.dur - 0.001) {
      rests.push(rv.str);
      remaining -= rv.dur;
    }
  }

  return rests.length > 0 ? rests : ['R4'];
}

function removeRedundantVolumes(mmlLines) {
  // 1단계: 모든 라인을 합쳐서 토큰 단위로 처리
  const lineTokens = mmlLines.map(line => {
    if (!line.trim() || line.trim().startsWith('#')) {
      return { passthrough: true, text: line };
    }
    return { passthrough: false, tokens: line.split(/\s+/) };
  });

  // 2단계: 전체 토큰을 순회하면서 연속 V 처리
  // 먼저 모든 토큰을 평탄화하되 줄 경계를 기억
  const allTokens = [];
  const lineMap = []; // 각 토큰이 몇 번째 라인인지

  lineTokens.forEach((entry, lineIdx) => {
    if (entry.passthrough) return;
    entry.tokens.forEach(token => {
      allTokens.push({ token, lineIdx });
    });
  });

  // 연속 V에서 마지막만 남기기 + 직전 볼륨과 같으면 제거
  const keep = new Array(allTokens.length).fill(true);
  let lastVolume = null;

  for (let i = 0; i < allTokens.length; i++) {
    const token = allTokens[i].token;

    if (/^V\d+$/.test(token)) {
      // 다음 토큰도 V면 현재 제거
      if (i + 1 < allTokens.length && /^V\d+$/.test(allTokens[i + 1].token)) {
        keep[i] = false;
        continue;
      }
      // 직전 볼륨과 같으면 제거
      if (token === lastVolume) {
        keep[i] = false;
        continue;
      }
      lastVolume = token;
    }
  }

  // 3단계: 라인별로 재조립
  const tokensByLine = new Map();
  allTokens.forEach((entry, i) => {
    if (!keep[i]) return;
    if (!tokensByLine.has(entry.lineIdx)) {
      tokensByLine.set(entry.lineIdx, []);
    }
    tokensByLine.get(entry.lineIdx).push(entry.token);
  });

  return lineTokens.map((entry, lineIdx) => {
    if (entry.passthrough) return entry.text;
    const tokens = tokensByLine.get(lineIdx);
    return tokens ? tokens.join(' ') : '';
  });
}

    // L 명령어 최적화 함수
    function optimizeLengthCommands(mmlLines) {
      const optimized = [];
      let currentDefaultLength = '4';
      
      mmlLines.forEach(line => {
        if (!line.trim() || line.trim().startsWith('#')) {
          optimized.push(line);
          return;
        }
        
        const tokens = line.split(/\s+/);
        const lengthCounts = {};
        const noteTokens = [];
        
        tokens.forEach(token => {
          if (token.startsWith('V') || token.startsWith('T') || token === '>' || token === '<' || token.startsWith('L')) {
            return;
          }
          
          const notes = token.split('&');
          notes.forEach(note => {
            const match = note.match(/[A-GR][+\-]?(\d+\.?)/);
            if (match) {
              const length = match[1];
              lengthCounts[length] = (lengthCounts[length] || 0) + 1;
              noteTokens.push({ original: note, length: length });
            }
          });
        });
        
        let maxCount = 0;
        let bestLength = currentDefaultLength;
        
        for (const [length, count] of Object.entries(lengthCounts)) {
          if (count > maxCount) {
            maxCount = count;
            bestLength = length;
          }
        }
        
        const currentLengthCost = calculateLineCost(tokens, currentDefaultLength);
        const newLengthCost = calculateLineCost(tokens, bestLength) + (bestLength !== currentDefaultLength ? 2 + bestLength.length : 0);
        
        let processedLine = '';
        if (newLengthCost < currentLengthCost && bestLength !== currentDefaultLength) {
          processedLine = `L${bestLength} `;
          currentDefaultLength = bestLength;
        }
        
        const processedTokens = [];
        tokens.forEach(token => {
          if (token.startsWith('V') || token.startsWith('T') || token === '>' || token === '<') {
            processedTokens.push(token);
            return;
          }
          
          if (token.startsWith('L')) {
            return;
          }
          
          if (token.includes('&')) {
            const tiedNotes = token.split('&');
            const processed = tiedNotes.map(note => {
              return removeRedundantLength(note, currentDefaultLength);
            });
            processedTokens.push(processed.join('&'));
          } else {
            processedTokens.push(removeRedundantLength(token, currentDefaultLength));
          }
        });
        
        processedLine += processedTokens.join(' ');
        optimized.push(processedLine);
      });
      
      return optimized;
    }
    
    function calculateLineCost(tokens, defaultLength) {
      let cost = 0;
      
      tokens.forEach(token => {
        if (token.startsWith('V') || token.startsWith('T') || token === '>' || token === '<' || token.startsWith('L')) {
          cost += token.length + 1;
          return;
        }
        
        if (token.includes('&')) {
          const notes = token.split('&');
          notes.forEach((note, idx) => {
            const match = note.match(/([A-GR][+\-]?)(\d+\.?)/);
            if (match) {
              const [, noteName, length] = match;
              cost += noteName.length;
              if (length !== defaultLength) {
                cost += length.length;
              }
              if (idx < notes.length - 1) {
                cost += 1;
              }
            }
          });
          cost += 1;
        } else {
          const match = token.match(/([A-GR][+\-]?)(\d+\.?)/);
          if (match) {
            const [, noteName, length] = match;
            cost += noteName.length;
            if (length !== defaultLength) {
              cost += length.length;
            }
            cost += 1;
          } else {
            cost += token.length + 1;
          }
        }
      });
      
      return cost;
    }
    
    function removeRedundantLength(note, defaultLength) {
      const match = note.match(/([A-GR][+\-]?)(\d+\.?)/);
      if (match) {
        const [, noteName, length] = match;
        if (length === defaultLength) {
          return noteName;
        }
        return noteName + length;
      }
      return note;
    }
    
    function validateMusicXML(xmlDoc) {
      const hasSegno = xmlDoc.querySelector('segno');
      const hasCoda = xmlDoc.querySelector('coda');
      const hasDC = Array.from(xmlDoc.querySelectorAll('words')).some(w => 
        /D\.?\s*C\.?|Da Capo/i.test(w.textContent)
      );
      const hasDS = Array.from(xmlDoc.querySelectorAll('words')).some(w => 
        /D\.?\s*S\.?|Dal Segno/i.test(w.textContent)
      );
      const hasFine = Array.from(xmlDoc.querySelectorAll('words')).some(w => 
        /Fine/i.test(w.textContent)
      );
      
      if (hasSegno || hasCoda || hasDC || hasDS || hasFine) {
        throw new Error('이 악보에는 D.C., D.S., Segno, Coda, Fine 등의 반복 점프 기호가 포함되어 있습니다. 현재 이러한 기호는 지원하지 않습니다.');
      }
    }
    
    // 메인 변환 함수
    async function convertToMML() {
      if (!uploadedFile || isConverting) return;
      
      isConverting = true;
      resetProgress();
      hideWarning();
      hideValidationWarning();
      validationErrors = [];
      document.getElementById('progressSection').classList.add('active');
      setConvertButtonLoading(true);
      
      try {
        updateProgress(1, 'active');
        await sleep(300);
        
        let text = '';
        
        if (uploadedFile.name.toLowerCase().endsWith('.mxl')) {
          try {
            if (typeof JSZip === 'undefined') {
              const script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
              await new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
              });
            }
            
            const arrayBuffer = await uploadedFile.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            
            let mainFile = null;
            const containerFile = zip.file('META-INF/container.xml');
            if (containerFile) {
              const containerText = await containerFile.async('text');
              const containerDoc = new DOMParser().parseFromString(containerText, 'text/xml');
              const rootfile = containerDoc.querySelector('rootfile');
              if (rootfile) {
                const fullPath = rootfile.getAttribute('full-path');
                mainFile = zip.file(fullPath);
              }
            }
            
            if (!mainFile) {
              const xmlFiles = Object.keys(zip.files).filter(name => name.endsWith('.xml') && !name.includes('META-INF'));
              if (xmlFiles.length > 0) {
                mainFile = zip.file(xmlFiles[0]);
              }
            }
            
            if (!mainFile) {
              throw new Error('.mxl 파일 내부에 MusicXML 파일을 찾을 수 없습니다.');
            }
            
            text = await mainFile.async('text');
          } catch (error) {
            throw new Error('.mxl 파일 압축 해제 실패: ' + error.message);
          }
        } else {
          text = await uploadedFile.text();
        }
        
        updateProgress(1, 'complete');
        await sleep(200);
        
        updateProgress(2, 'active');
        await sleep(300);
        
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(text, "text/xml");
        
        if (xmlDoc.querySelector('parsererror')) {
          throw new Error('XML 파싱 실패: 잘못된 파일 형식입니다.');
        }
        
        validateMusicXML(xmlDoc);
        
        updateProgress(2, 'complete');
        await sleep(200);
        
        updateProgress(3, 'active');
        await sleep(300);
        
        const mode = document.querySelector('input[name="mode"]:checked').value;
        
        
        convertedMML = parseMusicXML(xmlDoc, mode, false);
        
        updateProgress(3, 'complete');
        await sleep(200);
        
        updateProgress(4, 'active');
        await sleep(300);
        
        displayPreview(convertedMML);
        
        document.getElementById('downloadBtn').disabled = false;
        
        if (validationErrors.length > 0) {
          showValidationWarning(validationErrors);
        }
        
        updateProgress(4, 'complete');
        
      } catch (error) {
        console.error('변환 오류:', error);
        
        for (let i = 1; i <= 4; i++) {
          const step = document.getElementById(`step${i}`);
          const icon = step.querySelector('.progress-icon');
          if (icon.classList.contains('active')) {
            updateProgress(i, 'error', '실패');
            break;
          }
        }
        
        showWarning('변환 중 오류가 발생했습니다: ' + error.message, error.stack);
      } finally {
        isConverting = false;
        setConvertButtonLoading(false);
      }
    }
    
    function parseMusicXML(xmlDoc, mode, debugMode = false) {
  let output = '';

  const parts = xmlDoc.querySelectorAll('part-list > score-part');

  if (parts.length === 0) {
    throw new Error('MusicXML 파일에 파트 정보가 없습니다.');
  }

  const partData = [];
  parts.forEach(part => {
    const partId = part.getAttribute('id');
    const rawName = part.querySelector('part-name')?.textContent || 'Unknown';
    const partName = rawName.replace(/[\n\r]+/g, ' ').trim() || 'Unknown';
    partData.push({ id: partId, name: partName });
  });

  const tempoElement = xmlDoc.querySelector('sound[tempo]');
  const globalTempo = tempoElement ? Math.round(tempoElement.getAttribute('tempo')) : 120;

  let hasContent = false;

  // ✅ 변경: expandResult 대신 expandOrder만 저장
  let referenceExpandOrder = null;

  partData.forEach(partInfo => {
    const partElement = xmlDoc.querySelector(`part[id="${partInfo.id}"]`);
    if (!partElement) {
      console.warn(`파트 ${partInfo.id}를 찾을 수 없습니다.`);
      return;
    }

    const staffCount = getStaffCount(partElement);
    if (staffCount === 0) {
      console.warn(`파트 ${partInfo.name}에 staff가 없습니다.`);
      return;
    }

    const measuresNodeList = partElement.querySelectorAll('measure');
    const measuresArray = Array.from(measuresNodeList);

    // ✅ 볼타 유무 체크
    const hasEnding = measuresArray.some(m => m.querySelector('ending'));
    const hasRepeat = measuresArray.some(m => m.querySelector('repeat[direction="backward"]'));

    let expandResult;

    if (!hasEnding && hasRepeat && referenceExpandOrder) {
      // ✅ 핵심 수정: expandOrder만 재사용하여 이 파트의 마디로 재구성
      
      expandResult = applyExpandOrder(measuresArray, referenceExpandOrder);
    } else {
      // 직접 expand
      expandResult = expandMeasuresWithRepeats(measuresArray);
    }

    // ✅ 볼타가 있는 첫 번째 파트의 expandOrder를 기준으로 저장
    if (hasEnding && !referenceExpandOrder) {
      referenceExpandOrder = expandResult.expandOrder;
    }

    for (let staffNum = 1; staffNum <= staffCount; staffNum++) {
      if (mode === 'melody' || mode === 'autoselect') {
        const melody = extractMelody(partElement, staffNum, globalTempo, debugMode, expandResult);
        if (melody && melody.trim().split(/\s+/).length > 3) {
          const lines = melody.split('\n');
          lines.splice(0, 0, 'R1');
          output += `${partInfo.name} Staff ${staffNum} 최고음 # T${globalTempo}\n${lines.join('\n')}\n\n\n\n`;
          hasContent = true;
        }
      } else {
        const harmonies = extractHarmony(partElement, staffNum, 2, globalTempo, debugMode, expandResult);
        harmonies.forEach(harmony => {
          if (harmony.notes && harmony.notes.trim().split(/\s+/).length > 3) {
            const lines = harmony.notes.split('\n');
            lines.splice(0, 0, 'R1');
            output += `${partInfo.name} Staff ${staffNum} ${harmony.label} # T${globalTempo}\n${lines.join('\n')}\n\n\n\n`;
            hasContent = true;
          }
        });
      }
    }
  });

  if (!hasContent) {
    throw new Error('변환 가능한 음표가 없습니다. 파일 형식을 확인해주세요.');
  }

  return output.trim();
}
    
    // groupNotesByTimeAllVoices 함수 전체 교체
function groupNotesByTimeAllVoices(measure, staffNum, partElement) {
  const notes = Array.from(measure.querySelectorAll('note'));
  const divisions = findDivisions(measure, partElement);
  
  // voice별로 타임라인 구축
  const voiceTimelines = new Map(); // voiceNum -> [{time, note}]
  
  notes.forEach(note => {
    const staff = note.querySelector('staff');
    const noteStaff = staff ? parseInt(staff.textContent) : 1;
    if (noteStaff !== staffNum) return;
    
    const grace = note.querySelector('grace');
    if (grace) return;
    
    const voice = note.querySelector('voice');
    const voiceNum = voice ? parseInt(voice.textContent) : 1;
    
    if (!voiceTimelines.has(voiceNum)) {
      voiceTimelines.set(voiceNum, []);
    }
    
    const timeline = voiceTimelines.get(voiceNum);
    
    const chord = note.querySelector('chord');
    
    // 현재 voice의 시간 계산
    let currentTime = 0;
    if (timeline.length > 0) {
      const lastEntry = timeline[timeline.length - 1];
      currentTime = lastEntry.time;
      
      if (!chord) {
        // 이전 노트의 duration만큼 시간 증가
        try {
          const prevDuration = calculateNoteDuration(lastEntry.note);
          currentTime += prevDuration;
        } catch (error) {
          currentTime += 1;
        }
      }
    }
    
    timeline.push({ time: currentTime, note: note });
    
  });
  
  // 모든 voice의 노트를 시간별로 병합
  const allTimePoints = new Set();
  voiceTimelines.forEach(timeline => {
    timeline.forEach(entry => allTimePoints.add(entry.time));
  });
  
  const sortedTimes = Array.from(allTimePoints).sort((a, b) => a - b);
  
  const timeGroups = sortedTimes.map(time => {
    const notesAtTime = [];
    let hasRest = false;
    let hasNote = false;
    
    voiceTimelines.forEach(timeline => {
      // 🔥 핵심 수정: find → filter로 변경하여 같은 시간의 모든 노트 찾기
      const entries = timeline.filter(e => Math.abs(e.time - time) < 0.001);
      
      entries.forEach(entry => {
        notesAtTime.push(entry.note);
        if (entry.note.querySelector('rest')) {
          hasRest = true;
        } else {
          hasNote = true;
        }
      });
    });
    
    return {
      time: time,
      notes: notesAtTime,
      isRest: hasRest && !hasNote // 모두 쉼표일 때만 true
    };
  });
  
  return timeGroups;
}
    
    function extractMelody(partElement, staffNum, globalTempo, debugMode = false, expandResult = null) {
  // expandResult가 없으면 직접 계산 (하위 호환)
  if (!expandResult) {
    const measuresNodeList = partElement.querySelectorAll('measure');
    expandResult = expandMeasuresWithRepeats(Array.from(measuresNodeList));
  }
  const measures = expandResult.measures;
  const originalIndexMap = expandResult.originalIndexMap;

  const tempoMap = new Map();
  measures.forEach((measure, index) => {
    const sound = measure.querySelector('sound[tempo]');
    if (sound) {
      const tempo = Math.round(sound.getAttribute('tempo'));
      tempoMap.set(index, tempo);
    }
  });

  let keySignature = getKeySignature(partElement);
  const dynamicsList = collectDynamics(partElement);
  const representativePitchMap = extractRepresentativePitches(partElement);

  const noteProcessor = new NoteProcessor(keySignature, dynamicsList);

  const initialTempoElement = partElement.querySelector('sound[tempo]');
  const initialTempo = initialTempoElement ? Math.round(initialTempoElement.getAttribute('tempo')) : globalTempo;

  let currentVolume = mapDynamicsToVolume('mf', dynamicsList);
  let mmlNotes = [`V${currentVolume}`];
  let currentOctave = 4;

  let lastNoteInfo = null;
  let tiedNotes = [];
  let measureNotes = [];
  let inTie = false;

  const staffStartMeasure = getStaffStartMeasure(partElement, staffNum);

  let currentTimeSignature = null;
  let currentDynamics = 'mf';
  let wedgeMode = null; // 'crescendo' 또는 'diminuendo'
  let currentTempo = initialTempo;

  const lastNoteableMeasure = noteProcessor.findLastNoteableMeasure(
    measures,
    originalIndexMap,
    staffNum,
    staffStartMeasure,
    'any'
  );

  let expandedStaffStartMeasure = 0;
  for (let i = 0; i < measures.length; i++) {
    const originalIndex = originalIndexMap.get(i);
    if (originalIndex >= staffStartMeasure) {
      expandedStaffStartMeasure = i;
      break;
    }
  }

  measures.forEach((measure, measureIndex) => {
    if (lastNoteableMeasure >= 0 && measureIndex > lastNoteableMeasure) {
      return;
    }

    const originalIndex = originalIndexMap.get(measureIndex);

    if (originalIndex < staffStartMeasure || measureIndex < expandedStaffStartMeasure) {
      const { duration, timeSignature } = calculateMeasureDuration(measure, currentTimeSignature);
      currentTimeSignature = timeSignature;

      if (tempoMap.has(measureIndex)) {
        currentTempo = tempoMap.get(measureIndex);
      }

      const newDynamics = getCurrentDynamics(measure, currentDynamics);
      if (newDynamics !== currentDynamics) {
        currentDynamics = newDynamics;
        const newVolume = mapDynamicsToVolume(currentDynamics, dynamicsList);
        if (newVolume !== currentVolume) {
          currentVolume = newVolume;
        }
      }

      let restMML;
      if (currentTimeSignature) {
        const { beats, beatType } = currentTimeSignature;
        restMML = [];
        for (let i = 0; i < beats; i++) {
          restMML.push('R' + beatType);
        }
      } else {
        restMML = convertDurationToMML(duration);
      }

      mmlNotes.push(restMML.join(' '));
      mmlNotes.push('');
      return;
    }

    const timeSignature = getTimeSignature(measure);
    if (timeSignature) {
      currentTimeSignature = timeSignature;
    }

    keySignature = updateKeySignature(measure, keySignature);
    noteProcessor.keySignature = keySignature;

    if (debugMode) {
      const measureNumber = measure.getAttribute('number') || (measureIndex + 1);
      const timeInfo = currentTimeSignature ? `${currentTimeSignature.beats}/${currentTimeSignature.beatType}` : '4/4';
      const keyInfo = keySignature.fifths === 0 ? 'C장조' :
                     keySignature.fifths > 0 ? `${keySignature.fifths}개 #조` :
                     `${Math.abs(keySignature.fifths)}개 ♭조`;

      if (measureNotes.length > 0) {
        mmlNotes.push(measureNotes.join(' '));
        measureNotes = [];
      }

      measureNotes.push(`# 마디 ${measureNumber}: ${timeInfo}, ${keyInfo}`);
    }

    const debugStartIndex = measureNotes.length;

    if (tempoMap.has(measureIndex)) {
      const newTempo = tempoMap.get(measureIndex);
      if (newTempo !== currentTempo) {
        currentTempo = newTempo;
        if (measureIndex > staffStartMeasure || newTempo !== globalTempo) {
          measureNotes.push(`T${currentTempo}`);
        }
      }
    }

    const newDynamics = getCurrentDynamics(measure, currentDynamics);
    if (newDynamics !== currentDynamics) {
      currentDynamics = newDynamics;
      const newVolume = mapDynamicsToVolume(currentDynamics, dynamicsList);
      const initialVolume = mapDynamicsToVolume('mf', dynamicsList);
      if (newVolume !== currentVolume) {
        currentVolume = newVolume;
        if (originalIndex > staffStartMeasure || newVolume !== initialVolume) {
          measureNotes.push(`V${currentVolume}`);
        }
      }
    }

    const accentDynamic = getAccentDynamic(measure);
    if (accentDynamic === 'fp') {
      measureNotes.push('V14');
    } else if (accentDynamic === 'sfz') {
      measureNotes.push('V15');
    }

    // ✅ 크레센도/디크레센도 wedge 감지
    const wedges = measure.querySelectorAll('direction wedge');
    for (const wedge of wedges) {
      const wedgeType = wedge.getAttribute('type');
      if (wedgeType === 'crescendo' || wedgeType === 'diminuendo') {
        wedgeMode = wedgeType;
      } else if (wedgeType === 'stop') {
        wedgeMode = null;
      }
    }

    // ✅ 크레센도/디크레센도 진행 중이면 볼륨 변화
    if (wedgeMode && originalIndex >= staffStartMeasure && measureIndex >= expandedStaffStartMeasure) {
      if (wedgeMode === 'crescendo' && currentVolume < 15) {
        currentVolume = Math.min(15, currentVolume + 1);
        measureNotes.push(`V${currentVolume}`);
      } else if (wedgeMode === 'diminuendo' && currentVolume > 1) {
        currentVolume = Math.max(1, currentVolume - 1);
        measureNotes.push(`V${currentVolume}`);
      }
    }

    const notes = measure.querySelectorAll('note');
    const dynamicsMapResult = getMeasureDynamicsMap(measure);
    const dynamicsMap = dynamicsMapResult.map;

    const notesList = Array.from(notes);
    let graceNoteDuration = 0;
    let graceNoteBuffer = [];
    let chordGroup = [];
    let currentVoiceForMeasure = null;
    let skipNonTripletTupletNotes = 0;

    for (let noteIndex = 0; noteIndex < notesList.length; noteIndex++) {
      const note = notesList[noteIndex];
      const staff = note.querySelector('staff');
      const noteStaff = staff ? parseInt(staff.textContent) : 1;

      if (noteStaff !== staffNum) continue;

      const voice = note.querySelector('voice');
      const voiceNum = voice ? parseInt(voice.textContent) : 1;

      if (!currentVoiceForMeasure) {
        currentVoiceForMeasure = voiceNum;
      }

      if (staffNum === 1) {
        if (voiceNum !== 1) continue;
      } else {
        if (voiceNum !== currentVoiceForMeasure) continue;
      }

      const currentIsNonTripletTuplet = isNonTripletTuplet(note);

      if (skipNonTripletTupletNotes > 0) {
        skipNonTripletTupletNotes--;
        continue;
      }

      if (currentIsNonTripletTuplet && skipNonTripletTupletNotes === 0) {
        const timeModification = note.querySelector('time-modification');
        if (timeModification) {
          const actualNotes = parseInt(timeModification.querySelector('actual-notes')?.textContent || '0');
          const normalNotes = parseInt(timeModification.querySelector('normal-notes')?.textContent || '0');
          skipNonTripletTupletNotes = actualNotes - 1;

          // ✅ 총 길이 계산: baseDuration × normalNotes
          const noteType = note.querySelector('type')?.textContent;
          let baseDuration = 0;
          if (noteType === 'whole') baseDuration = 4;
          else if (noteType === 'half') baseDuration = 2;
          else if (noteType === 'quarter') baseDuration = 1;
          else if (noteType === 'eighth') baseDuration = 0.5;
          else if (noteType === '16th') baseDuration = 0.25;
          else if (noteType === '32nd') baseDuration = 0.125;
          else if (noteType === '64th') baseDuration = 0.0625;

          const totalDuration = baseDuration * normalNotes;

          // ✅ 경고 메시지 추가
          const measureNumber = measure.getAttribute('number') || (measureIndex + 1);
          validationErrors.push(`마디 ${measureNumber}: ${actualNotes}연음 → 첫 음만 ${totalDuration}박으로 출력 (수동 변환 필요)`);

          // ✅ 첫 음의 pitch 추출
          const rest = note.querySelector('rest');
          if (rest) {
            // 쉼표인 경우 총 길이만큼 쉼표 출력
            const restParts = convertDurationToMML(totalDuration);
            restParts.forEach(part => measureNotes.push(part));
          } else {
            const noteInfo = noteProcessor.extractNoteInfo(note, representativePitchMap, originalIndex);
            if (noteInfo) {
              while (noteInfo.octave > currentOctave) {
                measureNotes.push('>');
                currentOctave++;
              }
              while (noteInfo.octave < currentOctave) {
                measureNotes.push('<');
                currentOctave--;
              }

              const mmlParts = splitDurationToMML(totalDuration);
              const tiedParts = mmlParts.map(part => noteInfo.noteName + part);
              measureNotes.push(tiedParts.join('&'));

              lastNoteInfo = { step: noteInfo.step, alter: noteInfo.alter, octave: noteInfo.octave };
            }
          }

          graceNoteDuration = 0;
          continue; // ✅ 첫 음 처리 완료, 다음 음으로
        }
      }

      const grace = note.querySelector('grace');
      if (grace) {
        const graceDur = noteProcessor.getGraceDuration(note);
        if (graceDur === null) continue;

        const noteInfo = noteProcessor.extractNoteInfo(note, representativePitchMap, originalIndex);
        if (!noteInfo) continue;

        graceNoteBuffer.push(noteInfo);
        continue;
      }

      if (graceNoteBuffer.length > 0) {
        const graceLength = graceNoteBuffer.length >= 4 ? '64' : '32';
        const graceDurEach = graceNoteBuffer.length >= 4 ? 0.0625 : 0.125;

        for (const graceInfo of graceNoteBuffer) {
          while (graceInfo.octave > currentOctave) {
            measureNotes.push('>');
            currentOctave++;
          }
          while (graceInfo.octave < currentOctave) {
            measureNotes.push('<');
            currentOctave--;
          }
          measureNotes.push(graceInfo.noteName + graceLength);
        }

        graceNoteDuration = graceDurEach * graceNoteBuffer.length;
        graceNoteBuffer = [];
      }

      const noteDynamics = dynamicsMap.get(note);
      if (noteDynamics && noteDynamics !== currentDynamics) {
        currentDynamics = noteDynamics;
        const newVolume = mapDynamicsToVolume(currentDynamics, dynamicsList);
        if (newVolume !== currentVolume) {
          const initialVolume = mapDynamicsToVolume('mf', dynamicsList);
          currentVolume = newVolume;
          if (originalIndex > staffStartMeasure || newVolume !== initialVolume) {
            measureNotes.push(`V${currentVolume}`);
          }
        }
      }

      const chord = note.querySelector('chord');
      const rest = note.querySelector('rest');

      if (rest) {
        if (chordGroup.length > 0) {
          const result = processChordGroupMelody(chordGroup, measureNotes, currentOctave, tiedNotes, lastNoteInfo, inTie,
                                                  noteProcessor, keySignature, currentVolume, graceNoteDuration);
          currentOctave = result.currentOctave;
          tiedNotes = result.tiedNotes;
          lastNoteInfo = result.lastNoteInfo;
          inTie = result.inTie;
          chordGroup = [];
          graceNoteDuration = 0;
        }

        if (tiedNotes.length > 0) {
          measureNotes.push(tiedNotes.join('&'));
          tiedNotes = [];
          lastNoteInfo = null;
          inTie = false;
        }

        const restMMLParts = noteProcessor.processRest(rest.parentElement, measure, partElement, currentTimeSignature);
        restMMLParts.forEach(part => {
          measureNotes.push(part);
        });

        graceNoteDuration = 0;
        continue;
      }

      const noteInfo = noteProcessor.extractNoteInfo(note, representativePitchMap, originalIndex);
      if (!noteInfo) continue;

      const midiNum = getMidiNumber(noteInfo.step, noteInfo.octave, noteInfo.alter);

      chordGroup.push({
        note: note,
        noteInfo: noteInfo,
        midi: midiNum,
        ornaments: note.querySelector('ornaments')
      });

      const nextNote = notesList[noteIndex + 1];
      const nextHasChord = nextNote && nextNote.querySelector('chord');
      const nextStaff = nextNote ? nextNote.querySelector('staff') : null;
      const nextStaffNum = nextStaff ? parseInt(nextStaff.textContent) : 1;
      const nextVoice = nextNote ? nextNote.querySelector('voice') : null;
      const nextVoiceNum = nextVoice ? parseInt(nextVoice.textContent) : 1;

      if (!nextHasChord || nextStaffNum !== staffNum || nextVoiceNum !== voiceNum) {
        const result = processChordGroupMelody(chordGroup, measureNotes, currentOctave, tiedNotes, lastNoteInfo, inTie,
                                                noteProcessor, keySignature, currentVolume, graceNoteDuration, accentDynamic);
        currentOctave = result.currentOctave;
        tiedNotes = result.tiedNotes;
        lastNoteInfo = result.lastNoteInfo;
        inTie = result.inTie;
        chordGroup = [];
        graceNoteDuration = 0;
      }
    }

    // ✅ forward만 있고 음표가 없는 마디 처리
    const hasNotes = Array.from(measure.querySelectorAll('note')).some(n => {
      const staff = n.querySelector('staff');
      const noteStaff = staff ? parseInt(staff.textContent) : 1;
      if (noteStaff !== staffNum) return false;
      const voice = n.querySelector('voice');
      const voiceNum = voice ? parseInt(voice.textContent) : 1;
      if (staffNum === 1 && voiceNum !== 1) return false;
      const grace = n.querySelector('grace');
      if (grace) return false;
      return true;
    });

    if (!hasNotes) {
      const forwards = measure.querySelectorAll('forward');
      if (forwards.length > 0) {
        const divisions = findDivisions(measure, partElement);
        let totalForwardDuration = 0;
        forwards.forEach(fwd => {
          const dur = parseInt(fwd.querySelector('duration')?.textContent || '0');
          totalForwardDuration += dur / divisions;
        });
        if (totalForwardDuration > 0.001) {
          const restParts = convertDurationToMML(totalForwardDuration);
          restParts.forEach(part => measureNotes.push(part));
        }
      }
    }

    if (debugMode && currentTimeSignature) {
      const expectedDuration = (currentTimeSignature.beats * 4) / currentTimeSignature.beatType;
      const actualNotesInMeasure = measureNotes.slice(debugStartIndex);
      const actualDuration = calculateActualMeasureDuration(actualNotesInMeasure);

      if (Math.abs(actualDuration - expectedDuration) > 0.01) {
        const measureNumber = measure.getAttribute('number') || (measureIndex + 1);
        const errorMsg = `# 경고: 예상 ${expectedDuration}박, 실제 ${actualDuration.toFixed(2)}박`;
        measureNotes.push(errorMsg);
        validationErrors.push(`마디 ${measureNumber}: 예상 ${expectedDuration}박, 실제 ${actualDuration.toFixed(2)}박`);
      }
    }

    if (!inTie && measureNotes.length > 0) {
      mmlNotes.push(measureNotes.join(' '));
      measureNotes = [];
    }

    currentVoiceForMeasure = null;
  });

  if (tiedNotes.length > 0) {
    measureNotes.push(tiedNotes.join('&'));
  }
  if (measureNotes.length > 0) {
    mmlNotes.push(measureNotes.join(' '));
  }

  const optimizedNotes = optimizeLengthCommands(mmlNotes);
   const cleanedNotes = removeRedundantVolumes(optimizedNotes);
   return cleanedNotes.join('\n');
}
    
    function processChordGroupMelody(chordGroup, measureNotes, currentOctave, tiedNotes, lastNoteInfo, inTie, 
                                    noteProcessor, keySignature, currentVolume, graceNoteDuration, accentDynamic = false) {
      if (chordGroup.length === 0) {
        return { currentOctave, tiedNotes, lastNoteInfo, inTie };
      }
      
      const hasArpeggiate = chordGroup.some(n => {
        const arpeggiate = n.note.querySelector('arpeggiate');
        return !!arpeggiate;
      });
      
      // processChordGroupMelody 함수 안의 아르페지오 분기(if (hasArpeggiate)) 전체를 아래로 교체

    if (hasArpeggiate) {
      const sortedNotes = [...chordGroup].sort((a, b) => a.midi - b.midi);
      
      const firstNote = sortedNotes[0].note;
      const { length } = noteProcessor.calculateLength(firstNote, graceNoteDuration);
      
      const isDotted = length && length.includes('.');
      const lengthNum = parseInt((length || '4').replace('.', ''));
      
      let totalQuarters = 4 / lengthNum;
      if (isDotted) totalQuarters *= 1.5;
      
      const noteCount = sortedNotes.length;
      
      let arpNoteLength = 32;
      let arpNoteDuration = 4 / 32;
      let totalUsed = arpNoteDuration * (noteCount - 1);
      
      if (totalUsed > totalQuarters * 0.95) {
        arpNoteLength = 64;
        arpNoteDuration = 4 / 64;
        totalUsed = arpNoteDuration * (noteCount - 1);
        
        if (totalUsed > totalQuarters * 0.95) {
          arpNoteLength = 128;
          arpNoteDuration = 4 / 128;
          totalUsed = arpNoteDuration * (noteCount - 1);
        }
      }
      
      const lastNoteDuration = totalQuarters - totalUsed;
      
      // 최고음 (아르페지오에서 멜로디로 사용될 음)
      const highestInArp = sortedNotes[sortedNotes.length - 1];
      const highestNote = highestInArp.note;
      const highestNoteInfo = highestInArp.noteInfo;
      
      // ✅ 최고음의 타이 정보 확인
      const tieStart = highestNote.querySelector('tie[type="start"]');
      const tieStop = highestNote.querySelector('tie[type="stop"]');
      
      if (lastNoteDuration <= 0.01) {
        sortedNotes.forEach((noteData) => {
          const noteLength = Math.round(lengthNum * noteCount);
          
          while (noteData.noteInfo.octave > currentOctave) {
            measureNotes.push('>');
            currentOctave++;
          }
          while (noteData.noteInfo.octave < currentOctave) {
            measureNotes.push('<');
            currentOctave--;
          }
          
          measureNotes.push(noteData.noteInfo.noteName + noteLength);
        });
        
        lastNoteInfo = { step: highestNoteInfo.step, alter: highestNoteInfo.alter, octave: highestNoteInfo.octave };
        return { currentOctave, tiedNotes, lastNoteInfo, inTie };
      }
      
      const lastNoteMMLParts = splitDurationToMML(lastNoteDuration);
      
      sortedNotes.forEach((noteData, index) => {
        const isLast = index === sortedNotes.length - 1;
        
        while (noteData.noteInfo.octave > currentOctave) {
          measureNotes.push('>');
          currentOctave++;
        }
        while (noteData.noteInfo.octave < currentOctave) {
          measureNotes.push('<');
          currentOctave--;
        }
        
        if (isLast) {
          const tiedNoteParts = lastNoteMMLParts.map(part => noteData.noteInfo.noteName + part);
          const noteStr = tiedNoteParts.join('&');
          
          // ✅ 타이 처리
          const currentNoteInfo = { step: noteData.noteInfo.step, alter: noteData.noteInfo.alter, octave: noteData.noteInfo.octave };
          const isSamePitch = isSameNote(lastNoteInfo, currentNoteInfo);
          
          if (tieStop && tiedNotes.length > 0 && isSamePitch) {
            // 이전 타이와 연결
            tiedNotes.push(noteStr);
            if (tieStart) {
              // 타이 계속 진행
              inTie = true;
              lastNoteInfo = currentNoteInfo;
            } else {
              // 타이 종료
              measureNotes.push(tiedNotes.join('&'));
              tiedNotes = [];
              inTie = false;
              lastNoteInfo = null;
            }
          } else if (tieStart) {
            // 새 타이 시작
            if (tiedNotes.length > 0) {
              measureNotes.push(tiedNotes.join('&'));
              tiedNotes = [];
            }
            tiedNotes.push(noteStr);
            inTie = true;
            lastNoteInfo = currentNoteInfo;
          } else {
            // 타이 없음
            if (tiedNotes.length > 0) {
              measureNotes.push(tiedNotes.join('&'));
              tiedNotes = [];
            }
            measureNotes.push(noteStr);
            inTie = false;
            lastNoteInfo = currentNoteInfo;
          }
        } else {
          measureNotes.push(noteData.noteInfo.noteName + arpNoteLength);
        }
      });
      
      return { currentOctave, tiedNotes, lastNoteInfo, inTie };
    }
      
      const highestNote = chordGroup.reduce((max, current) => 
        current.midi > max.midi ? current : max
      );
      
      const note = highestNote.note;
      const noteInfo = highestNote.noteInfo;
      
      let trillMark = null;
      let trillAlter = null;
      let tremolo = null;
      let tremoloLines = 0;
      
      for (const chordNote of chordGroup) {
        const ornaments = chordNote.ornaments;
        
        if (ornaments) {
          const trill = ornaments.querySelector('trill-mark');
          if (trill) {
            trillMark = trill;
            trillAlter = ornaments.querySelector('accidental-mark')?.textContent;
          }
          
          const trem = ornaments.querySelector('tremolo[type="single"]');
          if (trem) {
            tremolo = trem;
            tremoloLines = parseInt(trem.textContent || '3');
          }
        }
      }
      
      const accent = hasAccent(note);
      const staccato = hasStaccato(note);
      
      let accentVolume = null;
      if (accent && currentVolume < 15) {
        accentVolume = Math.min(currentVolume + 2, 15);
        measureNotes.push(`V${accentVolume}`);
      }
      
      while (noteInfo.octave > currentOctave) {
        measureNotes.push('>');
        currentOctave++;
      }
      while (noteInfo.octave < currentOctave) {
        measureNotes.push('<');
        currentOctave--;
      }
      
      const { length, adjustedDuration } = noteProcessor.calculateLength(note, graceNoteDuration);
      
      if (trillMark && length) {
        if (tiedNotes.length > 0) {
          measureNotes.push(tiedNotes.join('&'));
          tiedNotes = [];
          lastNoteInfo = null;
          inTie = false;
        }
        
        const trillMML = noteProcessor.generateTrillMML(noteInfo.noteName, noteInfo, length, keySignature, trillAlter);
        
        trillMML.forEach(item => {
          if (item.type === 'octave') {
            measureNotes.push(item.value);
            currentOctave += (item.value === '>') ? 1 : -1;
          } else {
            measureNotes.push(item.value);
          }
        });
        
        if (accentVolume !== null) {
          measureNotes.push(`V${currentVolume}`);
        }
      }
      else if (tremolo && length) {
        if (tiedNotes.length > 0) {
          measureNotes.push(tiedNotes.join('&'));
          tiedNotes = [];
          lastNoteInfo = null;
          inTie = false;
        }
        
        const tremoloMML = noteProcessor.generateTremoloMML(noteInfo.noteName, length, tremoloLines);
        
        tremoloMML.forEach(item => {
          measureNotes.push(item.value);
        });
        
        lastNoteInfo = { step: noteInfo.step, alter: noteInfo.alter, octave: noteInfo.octave };
        
        if (accentVolume !== null) {
          measureNotes.push(`V${currentVolume}`);
        }
      }
      else if (staccato) {
        if (tiedNotes.length > 0) {
          measureNotes.push(tiedNotes.join('&'));
          tiedNotes = [];
          lastNoteInfo = null;
          inTie = false;
        }
        
        const staccatoMML = noteProcessor.processStaccato(noteInfo.noteName, length, adjustedDuration);
        staccatoMML.forEach(item => {
          measureNotes.push(item);
        });
        
        lastNoteInfo = { step: noteInfo.step, alter: noteInfo.alter, octave: noteInfo.octave };
        
        if (accentVolume !== null) {
          measureNotes.push(`V${currentVolume}`);
        }
      }
      else {
        const currentNoteInfo = { step: noteInfo.step, alter: noteInfo.alter, octave: noteInfo.octave };
        
        const tieResult = noteProcessor.processTie(
          note, 
          noteInfo.noteName, 
          length, 
          adjustedDuration, 
          tiedNotes, 
          lastNoteInfo, 
          currentNoteInfo
        );
        
        tieResult.mml.forEach(item => measureNotes.push(item));
        tiedNotes = tieResult.tiedNotes;
        lastNoteInfo = tieResult.lastNoteInfo;
        inTie = tieResult.inTie;
      }
      
      if (accentVolume !== null) {
        measureNotes.push(`V${currentVolume}`);
      }
      
      return { currentOctave, tiedNotes, lastNoteInfo, inTie };
    }
    
   function extractBass(partElement, staffNum, globalTempo, debugMode = false, expandResult = null) {
  // expandResult가 없으면 직접 계산 (하위 호환)
  if (!expandResult) {
    const measuresNodeList = partElement.querySelectorAll('measure');
    expandResult = expandMeasuresWithRepeats(Array.from(measuresNodeList));
  }
  const measures = expandResult.measures;
  const originalIndexMap = expandResult.originalIndexMap;

  const tempoMap = new Map();
  measures.forEach((measure, index) => {
    const sound = measure.querySelector('sound[tempo]');
    if (sound) {
      const tempo = Math.round(sound.getAttribute('tempo'));
      tempoMap.set(index, tempo);
    }
  });

  let keySignature = getKeySignature(partElement);
  const dynamicsList = collectDynamics(partElement);
  const representativePitchMap = extractRepresentativePitches(partElement);

  const noteProcessor = new NoteProcessor(keySignature, dynamicsList);

  const initialTempoElement = partElement.querySelector('sound[tempo]');
  const initialTempo = initialTempoElement ? Math.round(initialTempoElement.getAttribute('tempo')) : globalTempo;

  let currentVolume = mapDynamicsToVolume('mf', dynamicsList);
  let mmlNotes = [`V${currentVolume}`];
  let currentOctave = 4;

  let lastNoteInfo = null;
  let tiedNotes = [];
  let measureNotes = [];
  let inTie = false;

  const staffStartMeasure = getStaffStartMeasure(partElement, staffNum);

  let currentTimeSignature = null;
  let currentDynamics = 'mf';
  let wedgeMode = null; // 'crescendo' 또는 'diminuendo'
  let currentTempo = initialTempo;

  const lastNoteableMeasure = noteProcessor.findLastNoteableMeasure(
    measures,
    originalIndexMap,
    staffNum,
    staffStartMeasure,
    'any'
  );

  let expandedStaffStartMeasure = 0;
  for (let i = 0; i < measures.length; i++) {
    const originalIndex = originalIndexMap.get(i);
    if (originalIndex >= staffStartMeasure) {
      expandedStaffStartMeasure = i;
      break;
    }
  }

  measures.forEach((measure, measureIndex) => {
    if (lastNoteableMeasure >= 0 && measureIndex > lastNoteableMeasure) {
      return;
    }

    const originalIndex = originalIndexMap.get(measureIndex);

    if (originalIndex < staffStartMeasure || measureIndex < expandedStaffStartMeasure) {
      const { duration, timeSignature } = calculateMeasureDuration(measure, currentTimeSignature);
      currentTimeSignature = timeSignature;

      if (tempoMap.has(measureIndex)) {
        currentTempo = tempoMap.get(measureIndex);
      }

      const newDynamics = getCurrentDynamics(measure, currentDynamics);
      if (newDynamics !== currentDynamics) {
        currentDynamics = newDynamics;
        const newVolume = mapDynamicsToVolume(currentDynamics, dynamicsList);
        if (newVolume !== currentVolume) {
          currentVolume = newVolume;
        }
      }

      let restMML;
      if (currentTimeSignature) {
        const { beats, beatType } = currentTimeSignature;
        restMML = [];
        for (let i = 0; i < beats; i++) {
          restMML.push('R' + beatType);
        }
      } else {
        restMML = convertDurationToMML(duration);
      }

      mmlNotes.push(restMML.join(' '));
      mmlNotes.push('');
      return;
    }

    const timeSignature = getTimeSignature(measure);
    if (timeSignature) {
      currentTimeSignature = timeSignature;
    }

    keySignature = updateKeySignature(measure, keySignature);    
    noteProcessor.keySignature = keySignature;

    if (debugMode) {
      const measureNumber = measure.getAttribute('number') || (measureIndex + 1);
      const timeInfo = currentTimeSignature ? `${currentTimeSignature.beats}/${currentTimeSignature.beatType}` : '4/4';
      const keyInfo = keySignature.fifths === 0 ? 'C장조' :
                     keySignature.fifths > 0 ? `${keySignature.fifths}개 #조` :
                     `${Math.abs(keySignature.fifths)}개 ♭조`;

      if (measureNotes.length > 0) {
        mmlNotes.push(measureNotes.join(' '));
        measureNotes = [];
      }

      measureNotes.push(`# 마디 ${measureNumber}: ${timeInfo}, ${keyInfo}`);
    }

    const debugStartIndex = measureNotes.length;

    if (tempoMap.has(measureIndex)) {
      const newTempo = tempoMap.get(measureIndex);
      if (newTempo !== currentTempo) {
        currentTempo = newTempo;
        if (measureIndex > staffStartMeasure || newTempo !== globalTempo) {
          measureNotes.push(`T${currentTempo}`);
        }
      }
    }

    const newDynamics = getCurrentDynamics(measure, currentDynamics);
    if (newDynamics !== currentDynamics) {
      currentDynamics = newDynamics;
      const newVolume = mapDynamicsToVolume(currentDynamics, dynamicsList);
      const initialVolume = mapDynamicsToVolume('mf', dynamicsList);
      if (newVolume !== currentVolume) {
        currentVolume = newVolume;
        if (originalIndex > staffStartMeasure || newVolume !== initialVolume) {
          measureNotes.push(`V${currentVolume}`);
        }
      }
    }

    const accentDynamic = getAccentDynamic(measure);
    if (accentDynamic === 'fp') {
      measureNotes.push('V14');
    } else if (accentDynamic === 'sfz') {
      measureNotes.push('V15');
    }

    // ✅ 크레센도/디크레센도 wedge 감지
    const wedges = measure.querySelectorAll('direction wedge');
    for (const wedge of wedges) {
      const wedgeType = wedge.getAttribute('type');
      if (wedgeType === 'crescendo' || wedgeType === 'diminuendo') {
        wedgeMode = wedgeType;
      } else if (wedgeType === 'stop') {
        wedgeMode = null;
      }
    }

    // ✅ 크레센도/디크레센도 진행 중이면 볼륨 변화
    if (wedgeMode && originalIndex >= staffStartMeasure && measureIndex >= expandedStaffStartMeasure) {
      if (wedgeMode === 'crescendo' && currentVolume < 15) {
        currentVolume = Math.min(15, currentVolume + 1);
        measureNotes.push(`V${currentVolume}`);
      } else if (wedgeMode === 'diminuendo' && currentVolume > 1) {
        currentVolume = Math.max(1, currentVolume - 1);
        measureNotes.push(`V${currentVolume}`);
      }
    }

    const dynamicsMapResult = getMeasureDynamicsMap(measure);
    const dynamicsMap = dynamicsMapResult.map;

    const timeGroups = groupNotesByTimeAllVoices(measure, staffNum, partElement);

    let lastBassEndTime = -1;

    timeGroups.forEach((group, groupIndex) => {
      const currentTime = group.time;

      if (group.isRest) {
        if (tiedNotes.length > 0) {
          measureNotes.push(tiedNotes.join('&'));
          tiedNotes = [];
          lastNoteInfo = null;
          inTie = false;
        }

        const restMMLParts = noteProcessor.processRest(group.notes[0], measure, partElement, currentTimeSignature);
        restMMLParts.forEach(part => {
          measureNotes.push(part);
        });

        lastBassEndTime = -1;
      } else {
        const notesWithInfo = [];

        group.notes.forEach(note => {
          const rest = note.querySelector('rest');
          if (rest) return;

          const noteInfo = noteProcessor.extractNoteInfo(note, representativePitchMap, originalIndex);
          if (!noteInfo) return;

          const midiNum = getMidiNumber(noteInfo.step, noteInfo.octave, noteInfo.alter);

          const noteDynamics = dynamicsMap.get(note);
          if (noteDynamics && noteDynamics !== currentDynamics) {
            currentDynamics = noteDynamics;
            const newVolume = mapDynamicsToVolume(currentDynamics, dynamicsList);
            if (newVolume !== currentVolume) {
              const initialVolume = mapDynamicsToVolume('mf', dynamicsList);
              currentVolume = newVolume;
              if (originalIndex > staffStartMeasure || newVolume !== initialVolume) {
                if (tiedNotes.length > 0) {
                  measureNotes.push(tiedNotes.join('&'));
                  tiedNotes = [];
                  inTie = false;
                }
                measureNotes.push(`V${currentVolume}`);
              }
            }
          }

          notesWithInfo.push({
            note: note,
            noteInfo: noteInfo,
            midi: midiNum,
            ornaments: note.querySelector('ornaments')
          });
        });

        if (notesWithInfo.length === 1) {
          if (currentTime < lastBassEndTime - 0.001) {
            return;
          }

          if (tiedNotes.length > 0) {
            measureNotes.push(tiedNotes.join('&'));
            tiedNotes = [];
            lastNoteInfo = null;
            inTie = false;
          }

          const singleNote = notesWithInfo[0].note;
          const timeModification = singleNote.querySelector('time-modification');
          const isTriplet = timeModification &&
                            parseInt(timeModification.querySelector('actual-notes')?.textContent || '0') === 3 &&
                            parseInt(timeModification.querySelector('normal-notes')?.textContent || '0') === 2;

          const nextGroup = timeGroups[groupIndex + 1];
          let restDuration = 1;

          if (nextGroup) {
            restDuration = nextGroup.time - currentTime;
          } else {
            try {
              restDuration = calculateNoteDuration(singleNote);
            } catch (error) {
              restDuration = 1;
            }
          }

          let restMML;
          if (isTriplet) {
            restMML = convertDurationToTripletMML(restDuration);
          } else {
            restMML = convertDurationToMML(restDuration);
          }

          restMML.forEach(part => measureNotes.push(part));
          return;
        }

        if (notesWithInfo.length === 0) {
          if (currentTime < lastBassEndTime - 0.001) {
            return;
          }

          if (tiedNotes.length > 0) {
            measureNotes.push(tiedNotes.join('&'));
            tiedNotes = [];
            lastNoteInfo = null;
            inTie = false;
          }

          const nextGroup = timeGroups[groupIndex + 1];
          let restDuration = 1;

          if (nextGroup) {
            restDuration = nextGroup.time - currentTime;
          } else {
            try {
              restDuration = calculateNoteDuration(group.notes[0]);
            } catch (error) {
              restDuration = 1;
            }
          }

          const restMML = convertDurationToMML(restDuration);
          restMML.forEach(part => measureNotes.push(part));
          return;
        }

        const lowestNote = notesWithInfo.reduce((min, current) =>
          current.midi < min.midi ? current : min
        );

        try {
          const noteDuration = calculateNoteDuration(lowestNote.note);
          lastBassEndTime = currentTime + noteDuration;
        } catch (error) {
          lastBassEndTime = currentTime + 1;
        }

        const result = processChordGroupMelody(
          [lowestNote],
          measureNotes,
          currentOctave,
          tiedNotes,
          lastNoteInfo,
          inTie,
          noteProcessor,
          keySignature,
          currentVolume,
          0,
          accentDynamic
        );

        currentOctave = result.currentOctave;
        tiedNotes = result.tiedNotes;
        lastNoteInfo = result.lastNoteInfo;
        inTie = result.inTie;
      }
    });

    // ✅ forward만 있고 음표가 없는 마디 처리
    const hasNotes = Array.from(measure.querySelectorAll('note')).some(n => {
      const staff = n.querySelector('staff');
      const noteStaff = staff ? parseInt(staff.textContent) : 1;
      if (noteStaff !== staffNum) return false;
      const grace = n.querySelector('grace');
      if (grace) return false;
      return true;
    });

    if (!hasNotes) {
      const forwards = measure.querySelectorAll('forward');
      if (forwards.length > 0) {
        const divisions = findDivisions(measure, partElement);
        let totalForwardDuration = 0;
        forwards.forEach(fwd => {
          const dur = parseInt(fwd.querySelector('duration')?.textContent || '0');
          totalForwardDuration += dur / divisions;
        });
        if (totalForwardDuration > 0.001) {
          const restParts = convertDurationToMML(totalForwardDuration);
          restParts.forEach(part => measureNotes.push(part));
        }
      }
    }

    if (debugMode && currentTimeSignature) {
      const expectedDuration = (currentTimeSignature.beats * 4) / currentTimeSignature.beatType;
      const actualNotesInMeasure = measureNotes.slice(debugStartIndex);
      const actualDuration = calculateActualMeasureDuration(actualNotesInMeasure);

      if (Math.abs(actualDuration - expectedDuration) > 0.01) {
        const measureNumber = measure.getAttribute('number') || (measureIndex + 1);
        const errorMsg = `# 경고: 예상 ${expectedDuration}박, 실제 ${actualDuration.toFixed(2)}박`;
        measureNotes.push(errorMsg);
        validationErrors.push(`마디 ${measureNumber}: 예상 ${expectedDuration}박, 실제 ${actualDuration.toFixed(2)}박`);
      }
    }

    if (!inTie && measureNotes.length > 0) {
      mmlNotes.push(measureNotes.join(' '));
      measureNotes = [];
    }
  });

  if (tiedNotes.length > 0) {
    measureNotes.push(tiedNotes.join('&'));
  }
  if (measureNotes.length > 0) {
    mmlNotes.push(measureNotes.join(' '));
  }

  const optimizedNotes = optimizeLengthCommands(mmlNotes);
   const cleanedNotes = removeRedundantVolumes(optimizedNotes);
   return cleanedNotes.join('\n');
}
    
    function extractHarmony(partElement, staffNum, maxChannels, globalTempo, debugMode = false, expandResult = null) {
  const melodyResult = extractMelody(partElement, staffNum, globalTempo, debugMode, expandResult);
  const bassResult = extractBass(partElement, staffNum, globalTempo, debugMode, expandResult);

  return [
    { label: '최고음', notes: melodyResult },
    { label: '최저음', notes: bassResult }
  ];
}
    
    // distributeChordToChannels 함수 전체 교체
function distributeChordToChannels(chordNotes, channels, currentOctaves, maxChannels, keySignature, noteProcessor, graceNotes = []) {
  chordNotes.sort((a, b) => b.midi - a.midi);
  
  const hasArpeggiate = chordNotes.some(n => n.hasArpeggiate);
  const hasTrill = chordNotes.some(n => n.hasTrill);
  
  let topNoteGraceDuration = 0;
  let validGraceNotes = [];
  
  // Grace note 필터링 및 duration 계산
  if (graceNotes.length > 0 && chordNotes.length > 0) {
    validGraceNotes = graceNotes.filter(grace => {
      const ornaments = grace.querySelector('ornaments');
      if (ornaments) {
        const hasUnsupportedOrnament = 
          ornaments.querySelector('turn') ||
          ornaments.querySelector('mordent') ||
          ornaments.querySelector('inverted-mordent');
        return !hasUnsupportedOrnament;
      }
      return true;
    });
    
    if (validGraceNotes.length > 0) {
      topNoteGraceDuration = 0.125 * validGraceNotes.length;
    }
  }
  
  // Grace note를 최고음 채널에 먼저 출력
  if (validGraceNotes.length > 0) {
    const channel = channels[0];
    
    validGraceNotes.forEach(graceNote => {
      const pitch = graceNote.querySelector('pitch');
      if (!pitch) return;
      
      const step = pitch.querySelector('step')?.textContent;
      const octave = parseInt(pitch.querySelector('octave')?.textContent || '4');
      const alterElem = pitch.querySelector('alter');
      const alter = alterElem ? alterElem.textContent : null;
      
      if (!step || step.trim() === '') return;
      
      while (octave > currentOctaves[0]) {
        channel.measureNotes.push('>');
        currentOctaves[0]++;
      }
      while (octave < currentOctaves[0]) {
        channel.measureNotes.push('<');
        currentOctaves[0]--;
      }
      
      let graceNoteName = step;
      if (alter === '1') graceNoteName += '+';
      if (alter === '-1') graceNoteName -= '-';
      
      channel.measureNotes.push(graceNoteName + '32');
    });
  }
  
  if (hasArpeggiate && !hasTrill) {
    distributeArpeggioToChannel(chordNotes, channels[0], currentOctaves, keySignature);
    
    for (let i = 1; i < maxChannels; i++) {
      if (channels[i].tiedNotes.length > 0) {
        channels[i].measureNotes.push(channels[i].tiedNotes.join('&'));
        channels[i].tiedNotes = [];
      }
      channels[i].measureNotes.push('R');
      channels[i].lastNoteInfo = null;
      channels[i].inTie = false;
    }
    return;
  }
  
  let selectedNotes = [];
  
  if (chordNotes.length <= maxChannels) {
    selectedNotes = chordNotes;
  } else {
    selectedNotes.push(chordNotes[0]);
    
    if (maxChannels > 1 && chordNotes.length > 1) {
      selectedNotes.push(chordNotes[chordNotes.length - 1]);
    }
    
    const remaining = maxChannels - selectedNotes.length;
    const middleNotes = chordNotes.slice(1, -1);
    
    for (let i = 0; i < remaining && i < middleNotes.length; i++) {
      const index = Math.floor(i * middleNotes.length / remaining);
      selectedNotes.splice(selectedNotes.length - 1, 0, middleNotes[index]);
    }
  }
  
  for (let i = 0; i < maxChannels; i++) {
    const channel = channels[i];
    
    if (i < selectedNotes.length) {
      const note = selectedNotes[i];
      
      const graceAdjustment = topNoteGraceDuration;
      
      let accentVolume = null;
      if (note.hasAccent && channel.currentVolume < 15) {
        accentVolume = Math.min(channel.currentVolume + 2, 15);
        channel.measureNotes.push(`V${accentVolume}`);
      }
      
      if (note.hasTrill && note.length) {
        if (channel.tiedNotes.length > 0) {
          channel.measureNotes.push(channel.tiedNotes.join('&'));
          channel.tiedNotes = [];
          channel.lastNoteInfo = null;
          channel.inTie = false;
        }
        
        const noteInfo = { step: note.step, alter: note.alter, octave: note.octave };
        const trillMML = noteProcessor.generateTrillMML(note.name, noteInfo, note.length, keySignature, note.trillAlter);
        
        while (note.octave > currentOctaves[i]) {
          channel.measureNotes.push('>');
          currentOctaves[i]++;
        }
        while (note.octave < currentOctaves[i]) {
          channel.measureNotes.push('<');
          currentOctaves[i]--;
        }
        
        trillMML.forEach(item => {
          if (item.type === 'octave') {
            channel.measureNotes.push(item.value);
            currentOctaves[i] += (item.value === '>') ? 1 : -1;
          } else {
            channel.measureNotes.push(item.value);
          }
        });
        
        if (accentVolume !== null) {
          channel.measureNotes.push(`V${channel.currentVolume}`);
        }
      } else if (note.hasTremolo && note.length) {
        if (channel.tiedNotes.length > 0) {
          channel.measureNotes.push(channel.tiedNotes.join('&'));
          channel.tiedNotes = [];
          channel.lastNoteInfo = null;
          channel.inTie = false;
        }
        
        const tremoloMML = noteProcessor.generateTremoloMML(note.name, note.length, note.tremoloLines);
        
        while (note.octave > currentOctaves[i]) {
          channel.measureNotes.push('>');
          currentOctaves[i]++;
        }
        while (note.octave < currentOctaves[i]) {
          channel.measureNotes.push('<');
          currentOctaves[i]--;
        }
        
        tremoloMML.forEach(item => {
          channel.measureNotes.push(item.value);
        });
        
        channel.lastNoteInfo = { step: note.step, alter: note.alter, octave: note.octave };
        
        if (accentVolume !== null) {
          channel.measureNotes.push(`V${channel.currentVolume}`);
        }
      } else if (note.hasStaccato) {
        if (channel.tiedNotes.length > 0) {
          channel.measureNotes.push(channel.tiedNotes.join('&'));
          channel.tiedNotes = [];
          channel.lastNoteInfo = null;
          channel.inTie = false;
        }
        
        while (note.octave > currentOctaves[i]) {
          channel.measureNotes.push('>');
          currentOctaves[i]++;
        }
        while (note.octave < currentOctaves[i]) {
          channel.measureNotes.push('<');
          currentOctaves[i]--;
        }
        
        const staccatoMML = noteProcessor.processStaccato(note.name, note.length, null);
        staccatoMML.forEach(item => {
          channel.measureNotes.push(item);
        });
        
        channel.lastNoteInfo = { step: note.step, alter: note.alter, octave: note.octave };
        
        if (accentVolume !== null) {
          channel.measureNotes.push(`V${channel.currentVolume}`);
        }
      } else {
        // 🔥 일반 화음 처리 - 타이 연결 로직 추가
        const currentNoteInfo = { step: note.step, alter: note.alter, octave: note.octave };
        
        while (note.octave > currentOctaves[i]) {
          channel.measureNotes.push('>');
          currentOctaves[i]++;
        }
        while (note.octave < currentOctaves[i]) {
          channel.measureNotes.push('<');
          currentOctaves[i]--;
        }
        
        let adjustedDuration = null;
        if (graceAdjustment > 0 && note.length) {
          const lengthNum = parseInt(note.length.replace('.', ''));
          const isDotted = note.length.includes('.');
          const isTriplet = [6, 12, 24, 48].includes(lengthNum);
          
          let originalDuration = 0;
          if (isTriplet) {
            const baseLength = lengthNum / 3;
            originalDuration = 4 / baseLength;
          } else {
            originalDuration = 4 / lengthNum;
          }
          
          if (isDotted) {
            originalDuration *= 1.5;
          }
          
          const remainingDuration = originalDuration - graceAdjustment;
          if (remainingDuration > 0.001) {
            adjustedDuration = remainingDuration;
          }
        }
        
        // 🔥 핵심: 타이 처리 로직
        const isSamePitch = channel.lastNoteInfo && 
                           channel.lastNoteInfo.step === currentNoteInfo.step &&
                           channel.lastNoteInfo.alter === currentNoteInfo.alter &&
                           channel.lastNoteInfo.octave === currentNoteInfo.octave;
        
        // 현재 노트의 MML 생성
        let currentNoteMML;
        if (adjustedDuration) {
          const mmlParts = splitDurationToMML(adjustedDuration);
          const tiedNoteParts = mmlParts.map(part => note.name + part);
          currentNoteMML = tiedNoteParts.join('&');
        } else {
          currentNoteMML = note.name + (note.length || '');
        }
        
        // 타이 처리
        if (note.tieStop && channel.tiedNotes.length > 0 && isSamePitch) {
          // 이전 타이와 연결
          channel.tiedNotes.push(currentNoteMML);
          
          if (note.tieStart) {
            // 계속 타이 진행
            channel.inTie = true;
            channel.lastNoteInfo = currentNoteInfo;
          } else {
            // 타이 종료
            channel.measureNotes.push(channel.tiedNotes.join('&'));
            channel.tiedNotes = [];
            channel.inTie = false;
            channel.lastNoteInfo = null;
          }
        } else if (note.tieStart) {
          // 새로운 타이 시작
          if (channel.tiedNotes.length > 0) {
            // 이전 타이 종료
            channel.measureNotes.push(channel.tiedNotes.join('&'));
            channel.tiedNotes = [];
          }
          channel.tiedNotes.push(currentNoteMML);
          channel.inTie = true;
          channel.lastNoteInfo = currentNoteInfo;
        } else {
          // 타이 없음
          if (channel.tiedNotes.length > 0) {
            // 이전 타이 종료
            channel.measureNotes.push(channel.tiedNotes.join('&'));
            channel.tiedNotes = [];
          }
          channel.measureNotes.push(currentNoteMML);
          channel.inTie = false;
          channel.lastNoteInfo = currentNoteInfo;
        }
      }
      
      if (accentVolume !== null) {
        channel.measureNotes.push(`V${channel.currentVolume}`);
      }
    } else {
      if (channel.tiedNotes.length > 0) {
        channel.measureNotes.push(channel.tiedNotes.join('&'));
        channel.tiedNotes = [];
        channel.inTie = false;
      }
      channel.measureNotes.push('R' + selectedNotes[0].length);
      channel.lastNoteInfo = null;
    }
  }
}
    
    // distributeArpeggioToChannel 함수 (이전 수정 버전 그대로 유지)
function distributeArpeggioToChannel(chordNotes, channel, currentOctaves, keySignature) {
  const sortedNotes = [...chordNotes].sort((a, b) => a.midi - b.midi);
  
  const firstLength = sortedNotes[0].length || '4';
  const isDotted = firstLength.includes('.');
  const lengthNum = parseInt(firstLength.replace('.', ''));
  
  let totalQuarters = 4 / lengthNum;
  if (isDotted) totalQuarters *= 1.5;
  
  const noteCount = sortedNotes.length;
  
  let arpNoteLength = 32;
  let arpNoteDuration = 4 / 32;
  let totalUsed = arpNoteDuration * (noteCount - 1);
  
  if (totalUsed > totalQuarters * 0.95) {
    arpNoteLength = 64;
    arpNoteDuration = 4 / 64;
    totalUsed = arpNoteDuration * (noteCount - 1);
    
    if (totalUsed > totalQuarters * 0.95) {
      arpNoteLength = 128;
      arpNoteDuration = 4 / 128;
      totalUsed = arpNoteDuration * (noteCount - 1);
    }
  }
  
  const lastNoteDuration = totalQuarters - totalUsed;
  
  if (lastNoteDuration <= 0.01) {
    sortedNotes.forEach((note) => {
      const noteLength = Math.round(lengthNum * noteCount);
      
      if (note.hasAccent && channel.currentVolume !== 15) {
        channel.measureNotes.push('V15');
      }
      
      while (note.octave > currentOctaves[0]) {
        channel.measureNotes.push('>');
        currentOctaves[0]++;
      }
      while (note.octave < currentOctaves[0]) {
        channel.measureNotes.push('<');
        currentOctaves[0]--;
      }
      
      channel.measureNotes.push(note.name + noteLength);
      
      if (note.hasAccent && channel.currentVolume !== 15) {
        channel.measureNotes.push(`V${channel.currentVolume}`);
      }
    });
    return;
  }
  
  const lastNoteMMLParts = splitDurationToMML(lastNoteDuration);
  
  sortedNotes.forEach((note, index) => {
    const isLast = index === sortedNotes.length - 1;
    
    if (note.hasAccent && channel.currentVolume !== 15) {
      channel.measureNotes.push('V15');
    }
    
    while (note.octave > currentOctaves[0]) {
      channel.measureNotes.push('>');
      currentOctaves[0]++;
    }
    while (note.octave < currentOctaves[0]) {
      channel.measureNotes.push('<');
      currentOctaves[0]--;
    }
    
    if (isLast) {
      // 마지막 음 처리 (타이 고려)
      const tiedNoteParts = lastNoteMMLParts.map(part => note.name + part);
      const noteStr = tiedNoteParts.join('&');
      
      if (note.tieStart) {
        // 타이 시작: tiedNotes에 추가
        if (channel.tiedNotes.length > 0) {
          // 이미 진행 중인 타이가 있으면 먼저 종료
          channel.measureNotes.push(channel.tiedNotes.join('&'));
          channel.tiedNotes = [];
        }
        channel.tiedNotes.push(noteStr);
        channel.inTie = true;
        channel.lastNoteInfo = { step: note.step, alter: note.alter, octave: note.octave };
      } else if (note.tieStop && channel.tiedNotes.length > 0) {
        // 타이 종료: 이전 타이에 연결
        const isSamePitch = channel.lastNoteInfo && 
                           channel.lastNoteInfo.step === note.step &&
                           channel.lastNoteInfo.alter === note.alter &&
                           channel.lastNoteInfo.octave === note.octave;
        
        if (isSamePitch) {
          channel.tiedNotes.push(noteStr);
          
          // tieStart도 있으면 계속 진행
          if (!note.tieStart) {
            channel.measureNotes.push(channel.tiedNotes.join('&'));
            channel.tiedNotes = [];
            channel.inTie = false;
            channel.lastNoteInfo = null;
          } else {
            channel.inTie = true;
            channel.lastNoteInfo = { step: note.step, alter: note.alter, octave: note.octave };
          }
        } else {
          // 다른 음 - 이전 타이 종료하고 새로 시작
          channel.measureNotes.push(channel.tiedNotes.join('&'));
          channel.tiedNotes = [];
          channel.measureNotes.push(noteStr);
          channel.inTie = false;
          channel.lastNoteInfo = { step: note.step, alter: note.alter, octave: note.octave };
        }
      } else {
        // 타이 없음
        if (channel.tiedNotes.length > 0) {
          // 진행 중인 타이 종료
          channel.measureNotes.push(channel.tiedNotes.join('&'));
          channel.tiedNotes = [];
        }
        channel.measureNotes.push(noteStr);
        channel.inTie = false;
        channel.lastNoteInfo = { step: note.step, alter: note.alter, octave: note.octave };
      }
    } else {
      // 중간 음들 (아르페지오 32분음표 등)
      const noteStr = note.name + arpNoteLength;
      
      // 중간 음에는 타이를 적용하지 않음 (순차 출력)
      channel.measureNotes.push(noteStr);
    }
    
    if (note.hasAccent && channel.currentVolume !== 15) {
      channel.measureNotes.push(`V${channel.currentVolume}`);
    }
  });
}
    
    // 이벤트 리스너 등록
    document.getElementById('fileInput').addEventListener('change', handleFileUpload);   
    document.getElementById('convertBtn').addEventListener('click', convertToMML);
    document.getElementById('downloadBtn').addEventListener('click', downloadMML);
  </script>
</body>
</html>